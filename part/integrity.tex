\section{Механизмы обеспечения целостности СУБД}

\subsection{Угрозы целостности СУБД}

Задача обеспечения целостности предусматривает комплекс мер по предотвращению как непреднамеренного, так и преднамеренного изменения или уничтожения информации, используемой информационной системой управления или системой поддержки принятия решений. Изменение или уничтожение данных может быть следствием неблагоприятного стечения обстоятельств и состояния внешней среды (стихийные бедствия, пожары и т. п.), аппаратных или программных сбоев (отказ дисковой системы, нарушение целостности файлов БД, ошибки ПО), а также неадекватных действий пользователей (ошибки при вводе данных, ошибки операторов и т. п.) и проблем, возникающих при некорректной организации многопользовательской обработки данных, таких как некорректное управление конкурентным доступом, отсутствие механизмов блокировки и контроля изоляции транзакций. \autocite{Lihonosov2011, postgredoc1}.

Кроме того, угрозу целостности представляют преднамеренные атаки, например: SQL-инъекции, модификация данных привилегированными пользователями, эксплуатация уязвимостей в механизмах контроля доступа. Целостность данных также может быть нарушена в результате физического повреждения носителей информации (износ SSD/HDD, сбои в RAID-массивах, ошибки в системе хранения).

Например, при отсутствии механизмов контроля доступа, с помощью SQL-операторов UPDATE, INSERT и DELETE, злоумышленник или просто неопытный пользователь могут изменить данные в СУБД. Опасность заключается в том, что, при отсутствии принципа минимально необходимых привилегий, пользователь может получить возможность модифицировать все записи в таблице.  \autocite{Utebov2008, nist80012}.

\paragraph{Основные виды и причины возникновения угроз целостности} ~\\

Нарушение целостности информационной системы может произойти по разным причинам (включая технические сбои, ошибки конфигурирования, неправильные действия пользователя, преднамеренные атаки), и некоторые из этих причин могут также приводить и к нарушению доступности информации. \autocite{Pirogov2009}
Эти факторы можно разделить на внутренние (возникающие в результате ошибок эксплуатации или ПО) и внешние (обусловленные воздействием окружающего мира, злоумышленников, технических сбоев) \autocites{IntuitThreats, HabrCloudThreats, WikiExploit, KasperskyDailyOAuth}:

\begin{enumerate}
\item \textbf{Внутренние угрозы целостности ИС}.
    \begin{itemize}
        \item Случайное или умышленное отступление от правил эксплуатации. Например, правила могут предусматривать определенный набор параметров сервера (объем памяти, производительность процессора, объем дискового пространства, версия операционной системы и т.п.), на котором предполагается использовать ИС. Сюда же можно отнести, например, некорректную настройку резервного копирования или преднамеренное отключение логирования.;
        \item Ошибки конфигурирования системы на этапах установки, обновления, эксплуатации. Например, неправильное (необдуманное) управление правами доступа, незащищенные сетевые интерфейсы и т.д.
        \item Отказ программного обеспечения. Может быть вызван ошибками разработки, какими-то некорректными обновлениями, ну или преднамеренными изменениями кода (например, внедрение вредоносного ПО).
	    \item Проблемы управления многопользовательским доступом (состояния гонки, deadlock-ситуации, аномалии уровней изоляции транзакций).
    \end{itemize}

\item \textbf{Внешние угрозы целостности ИС}.
    \begin{itemize}
        \item Нарушение условий работы ИС, вызванные сбоями облачных сервисов и/или являющееся следствием зависимости от сторонних провайдеров (проблемы с системами связи, отключения электропитания, отопления и т.п.).
        \item Разрушение или повреждение помещений, связанное с природными катаклизмами. Конечно, такая ситуация на первый взгляд кажется мало возможной, но это вполне вероятно в регионах, например, с сейсмической неустойчивостью (привет Камчатке).
        \item Разрушение информации преднамеренными действиями злоумышленников или инсайдеров.
        \item Сетевые атаки, вредоносные программы (к примеру, шифровальщики, модифицирующие данные), SQL-инъекции, атаки на механизмы репликации и т.д.
	\item Эксплуатация уязвимостей в СУБД, физический доступ к оборудованию.
    \end{itemize}
\end{enumerate}

\paragraph{Способы противодействия} ~\\

Основными средствами защиты целостности информации в ИС являются \autocite{Pirogov2009}:

\begin{itemize}
    \item Транзакционные механизмы, позволяющие восстановить целостность данных в случае незначительных сбоев, ACID-свойства. \autocite{worksol1, DBtest};
    \item Контроль целостности на уровне базы данных. Реализация CHECK, FOREIGN KEY, NOT NULL и триггеров, предотвращающих некорректное изменение данных. \autocite{flenovinfo};
    \item Использование WAL (Write-Ahead Logging) - позволят сохранить изменение перед его внесением в основную базу. То есть проще сделать откат транзакции и восстановление данных. \autocite{WALintro};
    \item Резервное копирование данных. Использование PITR (point-in-time recovery), географически распределенная репликация на случай какого-то серьезного сбоя, \autocite{PITRintro};
    \item Периодическое тестирование системы на предмет нарушения целостности, анализ логов БД, а также использование IDS с целью попыток выявления попыток несанкционированного изменения данных \autocite{DBtest}.
    \item Использование отказоустойчивых серверов, UPS (системы бесперебойного питания), аппаратных средств шифрования, осуществление контроля доступа к серверному оборудованию \autocite{tolerance1, tolerance2}.

\end{itemize}

\subsection{Метаданные и словарь данных}

\begin{grayquote}
	\textbf{Метаданные} -- Это данные, описывающие другие данные. Это важный элемент хранилища данных, который предоставляет возможность показывать пользователю предметно-ориентированную структуру, а не набор абстрактно-связанных таблиц. Метаданные предназначены для хранения информации о происхождении данных, о любых изменениях данных, о расположении данных, об ограничениях на данные, о соответствии данных тем или иным объектам предметной области и т. д. \autocite{Pirogov2009}
\end{grayquote}

Говоря более простым языком: 
Если \textbf{данные} — то, что хранится в базе данных приложения (данные о клиентах, пользователях, заказах и т.п.), то \textbf{метаданные} — это описание структуры данных. Описание того, какие типы объектов хранятся в базе данных, какие у них есть поля (атрибуты, элементы), описание зависимостей между объектами. В общем случает типы могут наследовать атрибуты родительского типа, а один атрибут в общем случае может присутствовать у двух и более типов, несвязанных отношением наследования \autocite{Metadatahabr}.

\subsubsection{Назначение словаря данных}

Согласно реляционной модели данных, информация о структуре базы данных должна храниться в самой базе данных, в виде специальных таблиц. Это требование описано в 4-м правиле Кодда (Dynamic On-Line Catalog Based on the Relational Model), согласно которому СУБД должна автоматически управлять метаданными и обеспечивать их доступность через стандартные средства запросов.

Для организации хранения метаданных в реляционных СУБД используются системные каталоги, которые также называют <<словари данных>>.

\begin{grayquote}
    \textbf{Системный каталог} — это совокупность специальных таблиц, автоматически создаваемых и управляемых самой СУБД. Он содержит информацию о структуре базы данных, включая перечень таблиц, индексов, ограничений целостности, а также сведения о пользователях, их привилегиях и других параметрах системы \autocite{IntuitLec14}.
\end{grayquote}

Системные каталоги со временем развивались. Первые реализации каталогов появились еще в 1970-х годах в исследовательских проектах \textbf{IBM System R} и \textbf{Ingres}, но формально описание системного каталога было включено в стандарт \textbf{SQL-86}. В нем задавались базовые требования к хранению метаданных, но без единого формата их представления \autocite{DictHist}.

В \textbf{SQL-92} была стандартизирована структура системного каталога, а точнее представления, объединенные в схему \texttt{INFORMATION\_SCHEMA}. Эта штука в какой-то степени развязала руки разработчикам писать универсальные запросы для получения информации о таблицах, индексах, ограничениях и других объектах БД вне зависимости от конкретной СУБД. Однако на момент принятия стандарта, многие СУБД уже использовали собственные форматы каталогов, и их переход на \texttt{INFORMATION\_SCHEMA} оказался затруднительным.

\subsubsection{Реализация системных каталогов в разных СУБД}

Реализация и организация системных каталогов отличаются в зависимости от СУБД.

\begin{enumerate}
    \item \textbf{PostgreSQL}. \autocite{PostgreSQLdocc51,HabrDataOrgp1,YTcoursepostgre}
    
    В PostgreSQL системный каталог — это набор таблиц и представлений, содержащих метаданные обо всех объектах базы данных. Эти таблицы расположены в схеме \texttt{pg\_catalog}, которая по умолчанию включена в путь поиска. То есть можно обращаться к таблицам без явного указания схемы. Примеры таких таблиц: \texttt{pg\_class} (информация о таблицах и представлениях), \texttt{pg\_attribute} (сведения о столбцах) и \texttt{pg\_index} (данные об индексах). \autocite{PostgreSQLdocc51}

    Хотя системные каталоги и являются обычными таблицами, их прямое изменение не рекомендуется, так как это может привести к некорректной работе системы. Для внесения изменений рекомендуется использовать соответствующие SQL-команды, такие как \texttt{CREATE TABLE}, которая автоматически обновляет соответствующие записи в системном каталоге.

    Для получения информации из системного каталога рекомендуется использовать стандартные представления, наподобие \texttt{information\_schema}.

    Подробную информацию о системных каталогах PostgreSQL можно найти в официальной документации. \autocite{PostgreSQLdocc51}

    \item \textbf{MySQL}.
    
    В MySQL метаданные о базах данных и их объектах хранятся в специальной базе данных под названием \texttt{information\_schema}. Эта база данных содержит набор представлений, предоставляющих информацию о структурах баз данных (таблицах, столбцах, индексах, привилегиях пользователей).

    Например, представление \texttt{TABLES} в \texttt{information\_schema} содержит информацию обо всех таблицах, их имена, типы и используемые механизмы хранения. Представление \texttt{COLUMNS} дает сведения о столбцах таблиц (имена, типы данных и дополнительные характеристики).

    Доступ к данным в \texttt{information\_schema} осуществляется с помощью стандартных SQL-запросов. Например, получить список всех таблиц в определенной базе данных можно следующим запросом:

    \begin{lstlisting}[language=SQL]
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema = 'DATABASE_NAME';
    \end{lstlisting}

    Подробную информацию о структуре и содержимом \texttt{information\_schema} можно найти в официальной документации MySQL. \autocite{Mysqldoc1}
    
    Также стоит отметить, что в MySQL физическое хранение данных организовано в виде файловой системы, где каждая база данных представлена как подкаталог в основном каталоге данных сервера. Внутри каждого подкаталога файлы соответствуют таблицам и другим объектам базы данных. \autocite{IntuitMySQLadm}

    \item \textbf{Microsoft SQL Server}. \autocite{MicrosoftLearnSQLserver,professorweb,HabrTsql}

    В Microsoft SQL Server метаданные обо всех объектах базы данных хранятся в системных представлениях каталога, расположенных в схеме \texttt{sys}. Информация этих представлений содержит данные о таблицах, представлениях, столбцах, индексах, ограничениях и прочих объектах БД. Использование системных представлений позволяет администраторам и разработчикам получать структурированную информацию о состоянии БД и её объектах.
    
    \subparagraph{Основные представления каталога} ~\\
    
    Примеры наиболее часто используемых представлений:
    
    \begin{itemize}
        \item \texttt{sys.tables} — информация о всех таблицах в БД (имена, идентификаторы, даты создания);
        \item \texttt{sys.columns} — сведения о столбцах таблиц (имена, типы данных, порядковые номера);
        \item \texttt{sys.indexes} — информация об индексах (типы индексов, их назначение);
        \item \texttt{sys.foreign\_keys} — сведения о внешних ключах (ограничения ссылочной целостности);
        \item \texttt{sys.database\_principals} — информация о пользователях БД.
    \end{itemize}
    
    \subparagraph{Примеры запросов к системным представлениям} ~\\
    
    Для получения списка всех таблиц в текущей БД используется SQL-запрос:
    
    \begin{lstlisting}[language=SQL]
    SELECT name 
    FROM sys.tables;
    \end{lstlisting}
    
    Если необходимо получить список всех столбцов конкретной таблицы:
    
    \begin{lstlisting}[language=SQL]
    SELECT column_name, data_type, is_nullable
    FROM information_schema.columns
    WHERE table_name = 'Employees';
    \end{lstlisting}
    
    Для просмотра индексов таблицы:
    
    \begin{lstlisting}[language=SQL]
    SELECT i.name AS IndexName, t.name AS TableName
    FROM sys.indexes i
    JOIN sys.tables t ON i.object_id = t.object_id
    WHERE t.name = 'Employees';
    \end{lstlisting}
    
    \subparagraph{Рекомендации по использованию} ~\\
    
    Рекомендуется использовать системные представления каталога вместо прямого доступа к системным таблицам, так как представления:
    
    \begin{itemize}
        \item предоставляют стандартизированный интерфейс для получения метаданных;
        \item обеспечивают обратную совместимость при обновлении версий SQL Server;
        \item позволяют получать данные в удобном формате без необходимости разбираться во внутренней структуре системы.
    \end{itemize}

    \item \textbf{Oracle}.

    В Oracle Database словарь данных состоит из нескольких наборов представлений. Во многих случаях такой набор состоит из трех представлений, содержащих аналогичную информацию и отличающихся друг от друга своими префиксами \autocite{Kirillov2009}.\\

    Словарь данных базы данных Oracle имеет два основных применения:
    \begin{itemize}
        \item Oracle обращается к словарю данных каждый раз, когда выполняются команды языка DDL (Data Definition Language), например \texttt{CREATE TABLE}, \texttt{ALTER TABLE}, \texttt{DROP TABLE} и тд. Например, при создании таблицы Oracle вносить соответствующую запись в \texttt{DBA\_TABLES} и \texttt{ALL\_TABLES}.
        \item каждый пользователь Oracle может обращаться к словарю данных как к справочнику со сведениями по базе данных (доступные объекты). Например DBA может юзать словарь данных для мониторинга структуры схемы или например анализа привилегий юзеров
    \end{itemize}

    При этом словарь данных всегда доступен при открытой базе данных. Он размещается в табличном пространстве SYSTEM, которое всегда находится в состоянии Online, когда база данных открыта.

    Основные категории представлений \autocite{oracledbdoc1}:
    \begin{enumerate}

        \item \textbf{Представления с префиксом \texttt{USER\_}} содержат информацию об объектах, принадлежащих текущему пользователю. Например \texttt{USER\_TABLES} отображает таблицы, созданные текущим пользователем, а \texttt{USER\_TAB\_COLUMNS} даст информацию о столбцах таблиц пользователя.
        Пример запроса:
        \begin{lstlisting}[language=SQL]
            SELECT table_name 
            FROM user_tables;
        \end{lstlisting}

        \item \textbf{Представления с префиксом \texttt{ALL\_}} предоставляют информацию обо всех объектах, к которым текущий пользователь имеет доступ, независимо от владельца. Например \texttt{ALL\_TABLES} показывает все таблицы, доступные пользователю. \texttt{ALL\_TAB\_COLUMNS} показывает информацию о столбцах всех доступных таблиц.
        Пример запроса:
        \begin{lstlisting}[language=SQL]
            SELECT table_name 
            FROM all_tables 
            WHERE owner = 'HR';
        \end{lstlisting}

        \item \textbf{Представления с префиксом \texttt{DBA\_}} содержат информацию обо всех объектах в БД и доступны только пользователям с соответствующими привилегиями (типа админ). К примеру \texttt{DBA\_TABLES} предоставляет список всех таблиц в БД, \texttt{DBA\_USERS} - информацию обо всех пользователях БД.
        
        Пример запроса:
        \begin{lstlisting}[language=SQL]
            SELECT username 
            FROM dba_users;
        \end{lstlisting}

    \end{enumerate}

    Столбцы в представленных с префиксами \texttt{USER\_}, \texttt{ALL\_}, \texttt{DBA\_} идентичны, но есть нюанс. Объем данных возвращаемых каждый представлением зависит от прав доступа пользователя. В представлениях \texttt{USER\_} к примеру обычно нет столбца \texttt{OWNER}, так как подразумевается что владелец это текущий пользователь, выдавший запрос. Некоторые представления DBA имеют дополнительные столбцы, которые содержат информацию, полезную для БД.

    \textbf{Динамические представления производительности \texttt{V\textdollar}}. \autocite{oracledbdoc2}

    Помимо статических представлений словаря данных, Oracle предоставляет Dynamic Performance Views, также известные как \texttt{V\textdollar}-представления. Они содержат информацию о текущем состоянии БД и её производительности. Они обновляются в реальном времени и позволяют отслеживать активность системы, типа там текущие сессии, параметры, статистику производительности и тд. То есть используются они для мониторинга активности БД в реальном времени.

    Как пример можно привести \texttt{V\textdollar SESSION} (информация о текущих подключенных сессиях) или \texttt{V\textdollar PARAMETER} (текущие параметры конфигурации БД).

    Пример запроса:
    \begin{lstlisting}[language=SQL]
    SELECT sid, serial#, username, status 
    FROM v$session 
    WHERE status = 'ACTIVE';
    \end{lstlisting}
    
\end{enumerate}

\subsubsection{Логическая структура словаря данных}

Логическая структура словаря данных \autocite{PostgreSQLdocc51,ElmasriNavathe,Silberschatz} включает в себя:

\begin{enumerate}
    \item Описание структуры объектов базы данных (информация о таблицах, индексах, ограничениях, связях между объектами БД)
    \item Метаданные о транзакциях (сведения о выполняемых операциях, механизах блокировок, истории SQL-запросов)
    \item Статистику работы системы (данные о производительности, статистике выполнения запросов, параметрах конфигурации СУБД)
\end{enumerate}
Далее последовательно будут рассмотрены каждый из этих пунктов.

Также важно надо понимать разницу между \textbf{логической} и \textbf{физической} структурой словаря данных:

\begin{itemize}
    \item \textbf{Логическая структура} описывает, какие именно данные хранятся, в каком виде они представлены, как взоимосвязаны между собой.
    \item \textbf{Физическая структура} (рассмотрится далее) описывает где и как хранятся данные словаря, какие файлы и таблицы используются.
\end{itemize}

Словари данных могут быть \textbf{стандартные} и \textbf{вендор-зависимые}:

\begin{enumerate}
 
    \item Стандартные словари данных реализованы по международным стандартам SQL и обеспечивают SQL-запросы к словарю совместимыми между различными СУБД. Ключевой пример – схема \texttt{INFORMATION\_SCHEMA} (введенная в стандарт SQL-92). Оно поддерживается в MySQL, Microsoft SQL Server, PostgreSQL и других СУБД и позволяет разработать межплатформенные решения.

        \textbf{Пример SQL-запроса}:
        \begin{lstlisting}[language=SQL]
        SELECT table_name, column_name, data_type 
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE table_schema = 'public';
        \end{lstlisting}

    \item Вендор-зависимые словари данных реализованы специфическими разработчиками СУБД и как правило зачастую \textbf{предоставляют расширенные возможности, недоступные в стандартных словарях}. 

    Примеры вендор-зависимых системных каталогов:
    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_catalog} – содержит таблицы \texttt{pg\_tables}, \texttt{pg\_indexes}, \texttt{pg\_roles} (расширеные метаданные о структуре БД).
        \item Microsoft SQL Server: \texttt{sys.*} – набор системных представлений, включающий \texttt{sys.tables}, \texttt{sys.columns}, \texttt{sys.indexes} и другие.
        \item Oracle: \texttt{DBA\_*}, \texttt{ALL\_*}, \texttt{USER\_*} – системные представления для админов, юзеров и всех объектов бд.
    \end{itemize}

\end{enumerate}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Тип словаря} & \textbf{Пример в СУБД} & \textbf{Совместимость} \\
        \hline
        Стандартный & INFORMATION\_SCHEMA & Высокая (MySQL, SQL Server, PostgreSQL) \\
        \hline
        Вендор-зависимый & pg\_catalog (PostgreSQL) & Ограниченная (только PostgreSQL) \\
        \hline
        Вендор-зависимый & sys.* (SQL Server) & Только Microsoft SQL Server \\
        \hline
        Вендор-зависимый & DBA\_* (Oracle) & Только Oracle DB \\
        \hline
    \end{tabular}
    \caption{Стандартные и вендор-зависимые словари данных}
    \label{tab:data_dictionary_comparison}
\end{table}

Таким образом, использование вендор-зависимых требует всяких специфических знаний конкретной платформы.

Итак, перейдем к рассмотрению указанных ранее пунктов:

\paragraph{Основные объекты, хранящиеся в словаре данных}

\begin{enumerate}

    \item Таблицы и их атрибуты \autocites[§51.11]{PostgreSQLdocc51}[§28.3.38]{Mysqldoc1}{MicrosoftLearnSQLserver}

    Одним из основных компонентов словаря данных является информация о таблицах и их атрибутах. В реляционной модели данные организованы в виде таблиц, и их структура должна быть четко определена и документирована.

    \begin{enumerate}
        \item Метаданные о таблицах

        \begin{itemize}
            \item Название таблицы (\texttt{table\_name}).
            \item Схема (пространство имен) (\texttt{schema\_name}).
            \item Тип таблицы (обычная, временная, внешняя и т. д.).
            \item Дата создания и последнего изменения.
            \item Физическое расположение таблицы (табличное пространство, файловая группа).
            \item Владелец таблицы (создатель).
            \item Размер таблицы (количество строк, объем занимаемого пространства на диске).
        \end{itemize}

        Пример SQL-запроса (PostgreSQL, получение информации о таблицах):
        \begin{lstlisting}[language=SQL]
        SELECT schemaname, tablename, tableowner, tablespace 
        FROM pg_tables;
        \end{lstlisting}

        Примеры расположения метаданных о таблицах в разных СУБД:
        \begin{itemize}
            \item PostgreSQL: \texttt{pg\_class}, \texttt{pg\_tables}.
            \item MySQL: \texttt{INFORMATION\_SCHEMA.TABLES}.
            \item SQL Server: \texttt{sys.tables}.
            \item Oracle: \texttt{ALL\_TABLES}, \texttt{USER\_TABLES}, \texttt{DBA\_TABLES}.
        \end{itemize}

        \item Атрибуты (столбцы) таблиц
    
        Кроме информации о таблице в целом, важно хранить сведения о ее столбцах и их свойствах:
        
        \begin{itemize}
            \item Имя столбца (\texttt{column\_name}).
            \item Тип данных (\texttt{VARCHAR}, \texttt{INTEGER}, \texttt{BOOLEAN} и т. д.).
            \item Размерность данных (\texttt{length}, \texttt{precision}, \texttt{scale}).
            \item Значение по умолчанию.
            \item Является ли столбец автоинкрементным (\texttt{SERIAL}, \texttt{IDENTITY} и т. д.).
            \item Описание (комментарий к столбцу, если поддерживается СУБД).
        \end{itemize}

        Пример SQL-запроса (MySQL, получение информации о столбцах таблицы):
        \begin{lstlisting}[language=SQL]
        SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, IS_NULLABLE 
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE TABLE_NAME = 'employees';
        \end{lstlisting}
    \end{enumerate}
    
    \item Индексы \autocites[§51.26]{PostgreSQLdocc51}[§52.11]{PostgreSQLdocc52}[§28.3.34]{Mysqldoc1}{MicrosoftLearnSQLserverInd}

    Индексы важны в плане повышения производительности запросов. Они позволяют ускорить поиск данных, но увеличевают объем занимаемого дискового пространства.

    В словаре данных хранятся метаданные о индексах:
    \begin{itemize}
        \item Название индекса.
        \item Тип индекса (\texttt{B-Tree}, \texttt{Hash}, \texttt{GIN}, \texttt{Full-text}).
        \item Таблица, к которой индекс относиться.
        \item Столбцы, использованные для индексации.
        \item Параметры индекса (уникальность, сортировка, частичность).
        \item Статистика использования индекса (сколько раз использовался, степень фрагментации).
    \end{itemize}

    Примеры расположения индексов в разных СУБД:
    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_index}, \texttt{pg\_class}, \texttt{pg\_indexes}.
        \item MySQL: \texttt{INFORMATION\_SCHEMA.STATISTICS}.
        \item SQL Server: \texttt{sys.indexes}, \texttt{sys.index\_columns}.
        \item Oracle: \texttt{DBA\_INDEXES}, \texttt{USER\_INDEXES}.
    \end{itemize}

    Пример SQL-запроса (Oracle, получение информации об индексах таблицы):
    \begin{lstlisting}[language=SQL]
    SELECT INDEX_NAME, TABLE_NAME, UNIQUENESS, STATUS 
    FROM DBA_INDEXES 
    WHERE TABLE_NAME = 'EMPLOYEES';
    \end{lstlisting}

    \item Ограничения целостности \autocites[§51.13]{PostgreSQLdocc51}[§28.3.42]{Mysqldoc1}{MicrosoftLearnSQLserverTab}

    Органичения целостности служат для обеспечения корректности данных в таблицах. В них хранится следующая информация:
    \begin{itemize}
        \item Тип ограничения (\texttt{PRIMARY KEY} (определяет основной ключ таблицы), \texttt{FOREIGN KEY} (обеспечивает ссылочную целостность), \texttt{CHECK} (накладывает ограничения на значения столбцов), \texttt{UNIQUE} (гарантирует уникальность значений в таблице), \texttt{NOT NULL} (запрет хранить NULL в столбце))
        \item Целевая таблица (на которую наклыдвается ограничение целостности) и столбцы.
        \item Дейстия при удалени илии обновлении (\texttt{ON DELETE CASCADE}, \texttt{ON UPDATE SET NULL}).
    \end{itemize}

    Примеры раcположения метаданных об ограничениях в разных СУБД:
    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_constraint}
        \item MySQL: \texttt{INFORMATION\_SCHEMA.KEY\_COLUMN\_USAGE}, \texttt{INFORMATION\_SCHEMA.TABLE\_CONSTRAINTS}
        \item SQLServer: \texttt{sys.foreign\_keys}, \texttt{sys.check\_constraints}, \texttt{sys.key\_constraints}
        \item Oracle: \texttt{ALL\_CONSTRAINTS}, \texttt{USER\_CONSTRAINTS}, \texttt{DBA\_CONSTRAINTS}
    \end{itemize}

    Пример SQL-запроса (PostgreSQL, получение ограничений таблицы):
    \begin{lstlisting}[language=SQL]
    SELECT conname, contype, conrelid::regclass AS table_name 
    FROM pg_constraint 
    WHERE conrelid = 'employees'::regclass; 
    \end{lstlisting}

    Пример SQL-запроса (MySQL, ограничение \texttt{UNIQUE} на \texttt{email} в таблице \texttt{users}):
    \begin{lstlisting}[language=SQL]
    ALTER TABLE users
    ADD CONSTRAINT unique_email UNIQUE (email);    
    \end{lstlisting}

    Пример SQL-запроса (PostgreSQL, ограничение \texttt{FOREIGN KEY} для \texttt{orders.customer\_id}, ссылающееся на \texttt{customers.id}):
    \begin{lstlisting}[language=SQL]
    ALTER TABLE orders
    ADD CONSTRAINT fk_customer FOREIGN KEY (customer_id)
    REFERENCES customers(id) ON DELETE CASCADE;
    \end{lstlisting}

    \item Пользователи и их права \autocite{MicrosoftLearnSQLserverPerm, oracledbdoc3}

    Для управления доступом к БД в словаре данных хранится информация о пользователях, их привилегиях и ролях:
    \begin{itemize}
        \item Список всех пользователей СУБД (\texttt{user\_name} пользователей).
        \item Назначенные роли (\texttt{DBA}, \texttt{PUBLIC}, \texttt{SUPERUSER}).
        \item Гранты привилегий на обьекты (\texttt{SELECT}, \texttt{INSERT}, \texttt{UPDATE}, \texttt{DELETE}).
    \end{itemize}

	Примеры расположения метаданных о пользователях в разных СУБД:

    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_roles}, \texttt{pg\_authid}.
        \item MySQL: \texttt{mysql.user}, \texttt{INFORMATION\_SCHEMA.USER\_PRIVILEGES}.
        \item SQLServer: \texttt{sys.database\_principals}, \texttt{sys.database\_role\_members}.
        \item Oracle: \texttt{DBA\_USERS}, \texttt{ALL\_USERS}, \texttt{USER\_USERS}.
    \end{itemize}

    Пример SQL-запроса (PostgreSQL):
    \begin{lstlisting}[language=SQL]
    SELECT rolname, rolsuper, rolcreatedb, rolcanlogin 
    FROM pg_roles;             
    \end{lstlisting}

    Пример SQL-запроса (SQL Server, получение списка пользователей и их ролей):
    \begin{lstlisting}[language=SQL]
    SELECT name, type_desc 
    FROM sys.database_principals 
    WHERE type IN ('S', 'U');              
    \end{lstlisting}

\end{enumerate}

\paragraph{Метаданные о транзакциях} ~\\

\begin{grayquote}
    \textbf{Транзакция} - это исполняемая программа, включающая в себя определенные операции с базой данных, такие как чтение из базы данных, применение вставок, удалений или обновлений к базе данных \autocite{ElmasriNavathe}.
\end{grayquote}

Основной смысл транзакций заключается в в объединении нескольких операций в одно неделимое действие. Промежуточные состояния между шагами транзакции невидимы для других параллельно выполняющихся транзакций. Если происходит сбой, не позволяющий транзакции завершиться, то никакие изменения базу данных не затрагивают — все шаги откатываются. \autocite{PostgreSQLdocc3p4}

Соответственно, \textbf{метаданные о транзакциях} — это информация, фиксируемая СУБД в процессе выполнения транзакций. Они позволяют отслеживать историю изменений, анализировать работу БД и обеспечивать контроль целостности данных. В словаре данных хранятся в виде специальных системных таблиц и представлений, содержащих информацию о выполняемых операциях, механизмах блокировок, истории SQL-запросов.

\subparagraph{Журналы операций} ~\\

\textbf{Журналы операций} фиксируют информацию о транзакциях выполняемых в СУБД чтобы их можно было восстановить в случае сбоя (сделать \texttt{ROLLBACK}). Они являются основным источником информации о транзакциях в СУБД. Они фиксируют:
\begin{itemize}
    \item Время начала и завершения транзакции.
    \item ID транзакции.
    \item Тип выполняемой операции (INSERT, UPDATE, DELETE, DDL-операции).
    \item Пользователя, выполнявшего операцию.
    \item Затронутые (повергнувшиеся изменению) таблицы и строки.
    \item Использованные механизмы блокировок.
\end{itemize}

Используются они как уже было сказано для отката изменений (\texttt{ROLLBACK}).

Вот как это реализовано в различных СУБД:

\begin{itemize}
    \item PostgreSQL: Журналы транзаций хранятся в WAL (Write-Ahead Logging), а информация о транзакциях пишется в \texttt{pg\_xact} и \texttt{pg\_commit\_ts} \autocite{PostgreSQLdocc28}.
    \item MySQL использует бинарные логи (Binary Log, binlog), фиксирующие события для репликации и востановления. \autocite{Mysqldoc3}. Также есть штука \texttt{performance\_schema.events\_transactions}, которая фиксирует события связанные с выполнением транзакций и хранящяя подробную информацию о них (ID, состояния, временные метки начала и конца, статистику) \autocite{Mysqldoc2}. То есть binlog фиксирует изменения данных для цели репликации, восстановления, а эта штука используется для мониторинга работы транзакций в реальном времени, но не предназначена для восстановления данных. 
    \item SQL Server: журнал транзакций (Transaction Log), \texttt{sys.dm\_tran\_active\_transactions} \autocite{MicrosoftLearnSQLserverTransLog}.
    \item Oracle: журналы восстановления (Redo Logs), \texttt{V\textdollar TRANSACTION}, \texttt{V\textdollar LOG} \autocite{OracleRedoLog}.
\end{itemize}

Пример запроса (PostgreSQL, просмотр текущего состояния WAL-журнала. Как итог получаем текущий LSN (Log Sequence Number) в WAL-журнале. LSN указывает до какого момента были записаны изменения в журнале транзакций):
\begin{lstlisting}[language=SQL]
    SELECT * FROM pg_current_wal_lsn();                
\end{lstlisting}

Пример запроса (MySQL, просмотр 10 последних записанных в журнал транзакций событий, записанных в binlog):
\begin{lstlisting}[language=SQL]
    SHOW BINLOG EVENTS IN 'mysql-bin.000001' LIMIT 10;           
\end{lstlisting}

\subparagraph{История выполнения SQL-запросов} ~\\

Также многие СУБД ведут \textbf{историю выполненных SQL-запросов}. Она используется для анализа работы системы, поиска узких мест в производительности, аудит безопасности. 

Реализация следующая:
\begin{itemize}
    \item PostgreSQL: история запросов хранится в \texttt{pg\_stat\_statements} \autocite{PgStatStatements1}
    \item MySQL: используются \texttt{general\_log} и \texttt{slow\_query\_log} \autocite{Mysqldoc3}
    \item SQL Server: представление \texttt{sys.dm\_exec\_query\_stats} \autocite{MicrosoftLearnSQLserverQueryStat}
    \item Oracle: динамические представления \texttt{V\textdollar SQL}, \texttt{V\textdollar SQLAREA} \autocite[c.9 §46-49, c.9 §71]{oracledbdoc2}
\end{itemize}

Пример запроса (PostgreSQL, выводит 5 самых долгих рисурсоемких запросов):
\begin{lstlisting}[language=SQL]
    SELECT query, calls, total_exec_time 
    FROM pg_stat_statements 
    ORDER BY total_exec_time DESC 
    LIMIT 5;                 
\end{lstlisting}

Пример запроса (Oracle, \texttt{V\textdollar SQLAREA}, выборка последних запросов с частотой их выполнения и затратами ресурсов (10 штук запросов)):
\begin{lstlisting}[language=SQL]
    SELECT sql_text, executions, 
        elapsed_time / executions AS avg_exec_time, 
        disk_reads, buffer_gets 
    FROM V$SQLAREA 
    WHERE executions > 0 
    ORDER BY first_load_time DESC 
    FETCH FIRST 10 ROWS ONLY;
\end{lstlisting}

\subparagraph{Информация о блокировках и параллельном доступе} ~\\

Многопользовательский доступ требует механизмов блокировок для отсутствия ситуации, когда происходит одновременная модификация одних и тех же данных разными транзакциями. В словаре данных фиксируется информация о:
\begin{itemize}
    \item Активных блокировках (\texttt{SHARE}, \texttt{EXCLUSIVE}).
    \item Процессах, ожидающих снятия блокировок.
    \item Возникших взаимных блокировках (deadlocks).
    \item Длительности удержания блокировки.
    \item Таблицах и строках, находящихся в блокировке.
\end{itemize}

На практике реализовано следующим образом:
\begin{itemize}
    \item PostgreSQL: Информация о блокировках содержится в \texttt{pg\_locks} и \texttt{pg\_stat\_activity} \autocites[§52.12]{PostgreSQLdocc52}[§27.2.3]{PostgreSQLdocc27}.
    \item MySQL: \texttt{performance\_schema.metadata\_locks} \autocite[§29.12.13]{Mysqldoc2}.
    \item SQL Server: используется представление \texttt{sys.dm\_tran\_locks} \autocite{MicrosoftLearnSQLserverTranLocks}.
    \item Oracle: блокировки отслеживаются \texttt{V\textdollar LOCK}, \texttt{DBA\_BLOCKERS}, \texttt{DBA\_WAITERS} \autocites[c.8 §40]{oracledbdoc2}[c.4 §180, c.6 §103]{oracledbdoc1}.
\end{itemize}

Пример запроса (PostgreSQL, поиск процессов ожидающих блокировки):
\begin{lstlisting}[language=SQL]
    SELECT pid, relation::regclass AS locked_table, mode, granted
    FROM pg_locks
    WHERE NOT granted;              
\end{lstlisting}

Пример запроса (SQL Server, поиск взаимоблокировок):
\begin{lstlisting}[language=SQL]
    SELECT blocking_session_id AS blocker, session_id AS blocked
    FROM sys.dm_exec_requests
    WHERE blocking_session_id IS NOT NULL;             
\end{lstlisting}

Согласно требованиям ACID (Atomic, Consistent, Isolated, Durable) транзакция должна быть устойчивой. После своего завершения она сохраняется в системе, которую ничто не может вернуть в исходное (до начала транзакции) состояние, т. е. происходит фиксация транзакции (\texttt{COMMIT}), означающая, что ее действие постоянно даже при сбое системы. При выполнении отдельных операций транзакции могут быть нарушены какие-либо требования целостности данных (в первую очередь имеются в виду корпоративные правила целостности, см. главу 2). Однако по окончании выполнения транзакции (фиксация транзакции) все правила целостности базы данных будут соблюдены.

В большинстве реляционных СУБД фиксация сначала записывает изменения в журнал транзакций (например, WAL или Binary Log), а затем применяет их к основным данным. Это позволяет минимизировать потери в случае сбоя и поддерживать \texttt{ROLLBACK}, если транзакция не была завершена.

Транзакция начинается с первой команды, которая обращается к данным, и продолжается до тех пор, пока не будет явного завершения с помощью \texttt{COMMIT WORK} (или просто \texttt{COMMIT}) либо не будет закрыто соединение к базе данных. Также возможно явное открытие транзакции с помощью \texttt{BEGIN TRANSACTION} (\texttt{START TRANSACTION} в MySQL). При выполнении \texttt{COMMIT} происходит фиксация транзакции, и \texttt{ROLLBACK} уже будет невозможен \autocite{Pirogov2009}. Однако поведение на самом деле зависит от СУБД.

Например, в PostgreSQL и MySQL разрыв соединения без \texttt{COMMIT} приводит к автоматическому \texttt{ROLLBACK}, а в SQL Server и Oracle возможны различные настройки (по умолчанию транзакция фиксируется при разрыве соединение но можно включить поведение с откатом).

Пример явного управления транзакцией в PostgreSQL (демонстрация атомарности транзакции при переводе средств между мнимыми счетами):
\begin{lstlisting}[language=SQL]
    BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
    COMMIT;           
\end{lstlisting}


\paragraph{Статистика работы СУБД} ~\\

Статистика работы СУБД также представляет из себя метаданные которые фиксируют информацию о производительности системы, нагрузке на сервер, использовании индексов, частоте выполнения запросов. Подобного рода данные дают возможность админам анализировать производительность БД и оптимизировать систему.

\subparagraph{Анализ производительности} ~\\

Анализ производительности позволяет определить, какие запросы и операции замедляют работу СУБД. Для этого контролируется:
\begin{itemize}
    \item Использование процессора (время выполнения SQL-запросов, нагрузка на CPU)
    \item Операции чтения/записи на диск и использование кэша
    \item Потребление памяти (размер буферного кэша, использование индексов)
\end{itemize}

В разных СУБД следующие механизмы для анализа производительности:
\begin{itemize}
    \item PostgreSQL: \texttt{pg\_stat\_statements}, \texttt{pg\_stat\_activity}, \texttt{pg\_stat\_bgwriter} \autocite[§27.2]{PostgreSQLdocc27}
    \item MySQL: \texttt{performance\_schema}, \texttt{INFORMATION\_SCHEMA.PROCESSLIST} \autocite{Mysqldoc2}
    \item SQL Server: \texttt{sys.dm\_exec\_requests}, \texttt{sys.dm\_exec\_query\_stats} \autocite{MicrosoftLearnSQLserverSysDymView}
    \item Oracle: \texttt{V\textdollar SYSSTAT}, \texttt{V\textdollar SESSION}, \texttt{V\textdollar SQL} \autocite[c. 9 §9.98, §9.17, §9.46]{oracledbdoc2}
\end{itemize}

Пример PostgreSQL — анализ нагрузки активных запросов. Определяет SQL-запросы с наибольшим временем выполнения:
\begin{lstlisting}[language=SQL]
    SELECT pid, query, calls, total_exec_time / calls AS avg_exec_time
    FROM pg_stat_statements
    ORDER BY avg_exec_time DESC
    LIMIT 5;        
\end{lstlisting}

Другой пример (MySQL, анализ медленных запросов)
\begin{lstlisting}[language=SQL]
    SELECT start_time, user_host, query_time, sql_text
    FROM mysql.slow_log
    ORDER BY query_time DESC
    LIMIT 5;        
\end{lstlisting}

\subparagraph{Статистика выполнения запросов} ~\\

Статистические данные также используются для оптимизации индексов (анализируется частота обращения к различным таблицам), выявления <<дорогих>> запросов (запросов с высокой нагрузкой на процессор или диск) и настройки кэша и оценки эффективности буферизации данных.

Примеры механизмов сбора статистики запросов:
\begin{itemize}
    \item PostgreSQL: \texttt{pg\_stat\_statements} хранит частоту и среднее время выполнения запросов
    \item MySQL: \texttt{performance\_schema.events\_statements\_summary\_by\_digest} агрегирует запросы по шаблону
    \item SQL Server: \texttt{sys.dm\_exec\_query\_stats} дает информацию о частоте выполнения запросов
    \item Oracle: \texttt{V\textdollar SQLAREA} хранит статистику о выполненных запросах
\end{itemize}

Пример (SQL Server, анализ самых ресурсозатратных запросов)
\begin{lstlisting}[language=SQL]
    SELECT TOP 5 
        total_logical_reads AS Reads, 
        total_worker_time AS CPU_Time, 
        execution_count AS Executions, 
        text AS Query_Text 
    FROM sys.dm_exec_query_stats qs
    CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle)
    ORDER BY total_worker_time DESC;
\end{lstlisting}

Пример (Oracle, последние 10 выполненных запросов, показывает частоту и среднее время выполнения)
\begin{lstlisting}[language=SQL]
    SELECT sql_text, executions, elapsed_time / executions AS avg_exec_time
    FROM V$SQLAREA
    WHERE executions > 0
    ORDER BY first_load_time DESC
    FETCH FIRST 10 ROWS ONLY;
\end{lstlisting}

\subparagraph{Автоматическая сборка аналитики СУБД} ~\\

Некоторые (все из рассматриваемых четырех) СУБД автоматически анализируют статистику и используют её для внутренней оптимизации
\begin{itemize}
    \item PostgreSQL: \texttt{pg\_stat\_statements} автоматически анализирует запросы и создает план выполнения.
    \item MySQL: \texttt{performance\_schema.setup\_instruments} мониторит работу серверных процессов.
    \item SQL Server: \texttt{Query Store} хранит статистку выполнения запросов и их планы.
    \item Oracle: \texttt{V\textdollar SQL\_PLAN}, \texttt{V\textdollar SQL\_OPTIMIZER\_ENV} отслеживают параметры оптимизатора.
\end{itemize}

Пример (PostgreSQL, анализ частоты выполнения запросов)
\begin{lstlisting}[language=SQL]
    SELECT query, calls, total_exec_time / calls AS avg_exec_time
    FROM pg_stat_statements
    ORDER BY calls DESC
    LIMIT 10;
\end{lstlisting}

Пример (Oracle, анализ плана выполнения запроса)
\begin{lstlisting}[language=SQL]
    SELECT sql_id, plan_hash_value, executions, buffer_gets, elapsed_time
    FROM V$SQL_PLAN
    ORDER BY elapsed_time DESC
    FETCH FIRST 5 ROWS ONLY;
\end{lstlisting}

\subsubsection{Физическая структура словаря данных}

Здесь будет обсуждено хранение метаданных внутри файловой системы рассматриваемых СУБД. В отличие от логической структуры, которая описывает структуру и взаимосвязь данных на уровне схем и объектов БД, физическая структура это расположение системных файлов, их формат и механизмы работы с пространством на диске.

\paragraph{Расположение метаданных в файловой системе}
\subparagraph{PostgreSQL} \autocite{PostgreSQLdocc65} ~\\

PostgreSQL хранит метаданные о БД в системных таблицах, но сами файлы с данными располагаются в каталоге PGDATA, обычно \texttt{/var/lib/postgresql/<version>/main/} (в Linux) или \texttt{C:\textbackslash{}Program Files\textbackslash{}PostgreSQL\textbackslash{}<version>\textbackslash{}data\textbackslash{}} (в Windows)
Также основные файлы и каталоги, связанные с метаданными:
\begin{itemize}
    \item \texttt{pg\_catalog/} содержит системные таблицы с метаданными (\texttt{pg\_class}, \texttt{pg\_attribute}, \texttt{pg\_roles} и т.д.).
    \item \texttt{pg\_xact} фиксирует состояние транзакций.
    \item \texttt{pg\_wal} - журнал предзаписи (WAL) для восстановления.
    \item \texttt{base/} - директория с данными всех баз (каждая база имеет свой подкаталог).
\end{itemize}

\subparagraph{MySQL} \autocite[§17.6]{Mysqldoc4} ~\\

Используются два формата хранения метаданных: файловый и табличный.

\begin{itemize}
    \item \texttt{datadir/} - каталог, где хранятся базы данных (обычно \texttt{var/lib/mysql}).
    \item \texttt{ibdata1} - общий файл хранилища InnoDB, там записаны метаданные.
    \item \texttt{ib\_logfile0}, \texttt{ib\_logfile1} - файлы журнала транзакций InnoDB.
    \item \texttt{.frm} - файлы схем таблиц (используются в MyISAM).
    \item \texttt{.ibd} - файлы хранения данных и индексов для InnoDB. 
\end{itemize}

\subparagraph{SQL Server} \autocite{MicrosoftLearnSQLserverMasterdb,MicrosoftLearnSQLserverTempdb,MicrosoftLearnSQLserverDBfiles,MicrosoftLearnSQLserverFileLoc} ~\\

Тут метаданные хранятся в системной базе данных \texttt{master}, а физически - в файлах формата MDF (основные файлы БД) и LDF (журналы транзакций)

\begin{itemize}
    \item \texttt{\%ProgramFiles\%\textbackslash{}Microsoft SQL Server\textbackslash{}MSSQL<number>.MSSQLSERVER\textbackslash{}MSSQL\textbackslash{}DATA\textbackslash{}} - каталог с данными.
    \item \texttt{master.mdf} - основной файл БД с метаданными о сервере, содержит важные метаданные (информацию о всех базах, пользователях, настройках).
    \item \texttt{tempdb.mdf} - временное хранилище данных, временная база данных, для операций а-ля с сортировками и индексами.
\end{itemize}


\subparagraph{Oracle} \autocites[§1.338]{oracledbdoc0}{oracledbdoc4}{OracleRedoLog} ~\\

В Oracle для хранения метаданных используются табличные пространства (\texttt{tablespaces}) и бинарные файлы:

\begin{itemize}
    \item \texttt{SYSTEM tablespace} - файл данных содержащий основные метаданные и системный каталог базы данных.
    \item \texttt{SYSAUX tablespace} - вспомогательный табличный каталог-хранилище метаданных.
    \item \texttt{REDO*.log} - файлы журналов транзакций.
    \item \texttt{spfile.ora} - бинарный файл параметорв базы данных.
    \item \texttt{V\textdollar DATAFILE}, \texttt{DBA\_TABLES} - таблицы системного словаря.
\end{itemize}

\subsection{Блокировки и параллельный доступ}

Этот раздел посвящен механизмам блокировок в СУБД \autocites[c.22]{ElmasriNavathe}[c. 18]{Silberschatz}. Параллельный (конкурентный) доступ к одной и той же информации приводит к проблемам целостности данных, если не использовать механизмы блокировок и управления транзакциями.

Основные вопросы, рассматривающиеся в этой части:
\begin{itemize}
		\item Почему вообще возникает проблема конкурентного доступа и какие ошибки могут произойти?
		\item Какие виды блокировок существуют, и как помогают избежать конфликтов?
    \item Как разные СУБД реализуют управление блокировками?
    \item Какие вообще существуют стратегии решения конфликтов при параллельном доступе?
\end{itemize}

\subsubsection{Проблема параллельного доступа}

Нынешние СУБД поддерживают многопользовательский режим работы: несколько пользователей или процессов могут одновременно читать и изменять данные. И параллельное выполнение операций без соответствующих механизмов синхронизации может привести к некорректному состоянию базы данных и нарушению целостности данных \autocite{ElmasriNavathe, Silberschatz}.
Когда в базе данных одновременно выполняется несколько транзакций, свойство изоляции может больше не сохраняться. Чтобы обеспечить это, система должна контролировать взаимодействие между параллельными транзакциями. \autocite{Silberschatz}

\paragraph{Основные проблемы конкурентного доступа} ~\\

Конкурентный доступ может привести к следующим <<аномалиям>>:
\begin{enumerate}
    \item Lost Update (Потерянное обновление) ~\\
    Возникает, когда два процесса работают с одной и той же записью, но изменения которые сделал первый процесс, перезаписываются вторым, и тем самым первоначальные данные теряются.
    
    Пример (условный):
    \begin{itemize}
        \item Дима считывает значение \texttt{Баланс = 100}.
        \item Вася считывает то же значение \texttt{Баланс = 100}.
        \item Дима увеличивает баланс на \texttt{+50} и записывает \texttt{Баланс = 150}.
        \item Вася увеличивает баланс на \texttt{+30} (но он не знает, что Дима уже внес изменения) и записывает \texttt{Баланс = 130}.
        \item Итог: операция Димы канула в небытие, и баланс становится \texttt{130}, хотя должен быть \texttt{180}.
    \end{itemize}

    \item Dirty Read (Несогласованное чтение) ~\\
    Процесс читает данные, которые уже были изменены, но еще не были зафиксированы другой транзакцией. И если эта та транзакция откатится, то прочитанные данные окажутся недействительными (точнее, они вообще по идее <<никогда и не существовали>>).
    
    Пример:
    \begin{itemize}
        \item Изначально есть запись \texttt{Цена товара = 100}.
        \item Транзакция A обновляет \texttt{Цена товара = 200}, но \texttt{COMMIT} еще не выполнила.
        \item Транзакция B читает это \texttt{Цена товара = 200} и что-то делает дальше.
        \item Транзакция A делает \texttt{ROLLBACK}, возвращая \texttt{Цена товара = 100}.
        \item Итог: Транзакция B использовала неверные данные.
    \end{itemize}

    \item Non-repeatable Read (Неповторяющееся чтение) ~\\
    Происходит, когда транзакция повторно читает одну и ту же строку, но получает разные значения из-за того, что другая транзакция изменила или удалила эти данные и зафиксировала изменения.

    Пример:
    \begin{itemize}
        \item Транзакция A читает строку \texttt{id=1, balance=100} в таблице \texttt{accounts}.
        \item Транзакция B изменяет \texttt{balance} для \texttt{id=1} на 200 и выполняет \texttt{COMMIT}.
        \item Транзакция A снова читает \texttt{id=1} и получает \texttt{balance=200}, хотя в рамках одной транзакции ранее видела \texttt{balance=100}.
    \end{itemize}

    \item Phantom Read (Фантомное чтение) ~\\ 
    Явление считывания разных данных при одинаковом запросе. То есть процесс считывает набор данных (множество строк), потом делает повторный запрос, и видит новые или исчезнувшие записи из-за вмешательства (параллельного изменения этих данных) другой транзакции.

    Пример:
    \begin{itemize}
        \item Транзакция A запрашивает список сотрудников компании удовлетворяющих условию \texttt{зарплата < 30000}.
        \item Параллельно транзакция B добавляет нового сотрудника с \texttt{зарплата = 20000} и выполняется \texttt{COMMIT}.
        \item Транзакция A повторяет запрос и получает другой набор записей.
    \end{itemize}

    \item Race Condition (состояние гонки) ~\\
    Две транзакции <<конкурируют>> друг с другом за обновление одних и тех же данных без надлежащей синхронизации. Подобное может провести к непредсказуемому порядку выполнения операций и некорректным результатам.

    Пример: ~\\
    Два пользователя одновременно покупают последний товар на складе. Оба видят, что товар есть в наличии (условно, \texttt{stock = 1}), оба оформляют заказ и уменьшают \texttt{stock = 0}. Как итог база данных зафиксировала две продажи, но товар был только один.

\end{enumerate}

\paragraph{Причины возникновения проблем параллельного доступа} ~\\

\begin{itemize}
    \item Использование низкого уровня изоляции транзакций (см. ниже).
    \item Отсутствие блокировок (см. ниже).
    \item Некорректное управление многопользовательским доступом, к примеру отключение администраторами СУБД механизмов блокировок или снижение уровня изоляции ради повышения производительности.
\end{itemize}

\subsubsection{Уровни изоляции транзакций}

Уровни изоляции транзакций определяют, насколько одна транзакция может видеть изменения, внесенные другой транзакцией, прежде чем они будут зафиксированы в БД. Это на самом деле спорный аспект любой многопользовательской работы с БД, т.к. всегда баланс между целостностью данных и производительностью системы требует компромиссов.

Стандарт SQL-92 определяет четыре уровня изоляции транзакций, каждый из которых решает определенные проблемы параллельного доступа \autocite{ElmasriNavathe, Silberschatz}:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|p{4.25cm}|p{3.25cm}|p{3cm}|}
        \hline
        \textbf{Уровень изоляции} & \textbf{Описание} & \textbf{Метод реализации*} & \textbf{Используется по умолчанию} \\
        \hline
        \textbf{READ UNCOMMITTED} & Минимальный уровень изоляции, позволяющий одной транзакции видеть изменения, внесенные другой транзакцией, даже если они ещё не зафиксированы & Отсутствие блокировок & Почти не используется \\
        \hline
        \textbf{READ COMMITTED} & Транзакция видит только зафиксированные другими транзакциями изменения & Блокировки на уровне строк & PostgreSQL, Oracle, SQL Server \\
        \hline
        \textbf{REPEATABLE READ} & Гарантирует, что в рамках одной транзакции данные останутся неизменными & Блокировка строк на чтение и изменение & MySQL (InnoDB) \\
        \hline
        \textbf{SERIALIZABLE} & Максимальный уровень изоляции, полностью предотвращает параллельное выполнение транзакций. То есть обеспечивает выполнение транзакций так, будто они б выполнялись последовательно & Полная блокировка таблиц или снапшоты & PostgreSQL (опционально) \\
        \hline
    \end{tabular}
    \caption{Уровни изоляции транзакций и их характеристики}
    \label{tab:isolation_levels}
\end{table}
 *см. ниже <<Принципы работы изоляции транзакций>>

 Чем выше уровень изоляции, тем больше гарантирована целостность данных, но тем выше затраты на синхронизацию параллельно выполняемых транзакций

 \paragraph{Принципа работы изоляции транзакций} ~\\

 Изоляция обеспечивается за счет нескольких механизмов:
 \begin{enumerate}
     \item Механизмы блокировок (Locks) - транзакция блокирует строки или таблицы, другие транзакции не могут их изменять.
     \item MVCC (Multi-Version Concurrency Control) - транзакция работает с отдельными версиями строк, без блокировок.
     \item Снапшоты - механизм, при котором транзакция видит состояние БД на момент своего начала, независимо от других транзакций.
     \item Также иногда используется тема что вместо блокировок транзакции проверяют, не изменились ли данные с момента их первого чтения перед фиксацией изменений.
 \end{enumerate}
 
 \paragraph{Реализация уровней изоляции в разных СУБД} ~\\
 
 Каждая СУБД реализует изоляцию по-разному \autocites[§2]{PostgreSQLdocc13}[§17.7.2.1]{Mysqldoc4}{MicrosoftLearnSQLserverIsolation}{oracledbdoc5}
 
 \begin{enumerate}
     \item \textbf{PostrgeSQL} использует MVCC, по умолчанию работает в режиме READ COMMITTED, поддерживает SERIALIZABLE через снапшоты.
     \item \textbf{MySQL} по умолчанию REPEATABLE READ, использует gap locks для защиты от фантомного чтения.
     \item \textbf{SQL Server} поддерживает READ COMMITED SNAPSHOT, позволяет избежать блокировок при чтении.
     \item \textbf{Oracle} всегда работает в READ COMMITED, SERIALIZABLE реализуется через временные блокировки.
 \end{enumerate}
 
 Примеры установки уровня изоляции в разных СУБД:
 \begin{itemize}
     \item PostgreSQL
     \begin{lstlisting}[language=SQL]
         SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
     \end{lstlisting}
 
     \item MySQL
     \begin{lstlisting}[language=SQL]
         SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
     \end{lstlisting}
 
     \item SQL Server
     \begin{lstlisting}[language=SQL]
         SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
     \end{lstlisting}
 
     \item Oracle
     \begin{lstlisting}[language=SQL]
         ALTER SESSION SET ISOLATION_LEVEL SERIALIZABLE;
     \end{lstlisting}
 
 \end{itemize}
 
 \paragraph{Влияние изоляции на производительность} ~\\
 
 Логично, что выбор уровня изоляции влияет на производительность базы данных. И зависимость тут не замысловатая - чем больше блокировок, тем больше задержки. То есть обычная обратная зависимость
 
 \begin{table}[H]
     \centering
     \begin{tabular}{|c|c|c|}
         \hline
         \textbf{Уровень изоляции} & \textbf{Количество блокировок} & \textbf{Скорость} \\
         \hline
         \textbf{READ UNCOMMITTED} & Минимум & Максимальная \\
         \hline
         \textbf{READ COMMITTED} & Средне & Высокая \\
         \hline
         \textbf{REPEATABLE READ} & Высокая & Средняя \\
         \hline
         \textbf{SERIALIZABLE} & Максимальная & Низкая \\
         \hline
     \end{tabular}
     \caption{Влияние уровней изоляции на блокировки и производительность}
     \label{tab:isolation_performance}
 \end{table}
 
 В этом плане самый адекватный вариант - READ COMMITED: адекватный баланс между скоростью и корректностью данных. SERIALIZABLE используется в критично важных операциях, и сильно замедляет работу системы.
 
 \subsubsection{Виды блокировок}
 
 Блокировки в СУБД представляют из себя механизм, обеспечивающий согласованность и целостность данных при параллельном выполнении транзакций. Они позволяют избежать нежелательных эффектов, которые возникают при параллельном доступе, описанные ранее (см. 3.4.1)
 
 Основная цель механизма блокировок – координация доступа к данным так, чтобы конкурирующие транзакции не нарушали согласованность базы данных. Без применения блокировок параллельные операции могут привести к повреждению данных или нарушению согласованности транзакционного процесса. Опять же, как уже было сказано ранее, если два пользователя попытаются одновременно изменить одну и ту же строку таблицы без блокировки, возможен сценарий потери обновлений.
 
 Разные блокировки применяются в зависимости от уровня объекта, на который они накладываются, и сценария их использования:
 
 \begin{itemize}
     \item Для \textbf{чтения} данных важно предотвращать их модификацию во время выполнения запроса, но при этом оставлять возможность другим транзакциям также читать эти данные
     \item Для \textbf{модификации} данных надо исключить параллельное изменение одного и того же объекта (-> более жесткая блокировка)
     \item Разные уровни блокировок (на уровне базы/таблицы/строки и тд) позволяют <<балансировать>> между безопасность и производительностью системы (чем более <<гранулярна>> блокировка, тем меньше влияние на параллельную обработку данных, но тем выше сложность управления ей) \autocite[ch.22]{ElmasriNavathe}
 \end{itemize}
 
 Теперь рассмотрим основные виды блокировок в зависимости от уровня их накладывания:
 
 \paragraph{Классификация блокировок по объекту}
 \subparagraph{Блокировка базы данных (Database Lock)} ~\\

 Является самой грубой формой блокировки, при которой вся база данных становится недоступной для изменения другими процессами. Применяется при административных операциях (например, при резервном копировании с полным дампом данных), в случае каких-то глобальных изменений схемы (например, при изменении структуры БД), также долговременные аналитические запросы по идее также могут инициировать блокировку на уровне базы.
 
 Например, в MySQL команда \texttt{FLUSH TABLES WITH READ LOCK} накладывает глобальную блокировку базы данных, предотвращая запись, но оставляя чтение \autocite[§15.7.8.3]{Mysqldoc5}
 
 \subparagraph{Табличные блокировка (Table Lock)} ~\\

 Позволяют заблокировать всю таблицу, предотвращая внесение изменений другими транзакциями. Используется при долговременной обработке данных (к прмеру, при массовом обновлении или удалении) или, например, при изменении структуры таблицы.
 
 Примеры:
 \begin{itemize}
     \item В MySQL команда \texttt{LOCK TABLE employees WRITE} заблокирует таблицу для всех операций кроме тех, что выполняются в текущей сессии \autocite[§15.3.6]{Mysqldoc5}.
     \item В PostgreSQL \texttt{LOCK TABLE employees IN ACCESS EXCLUSIVE MODE} накладывает строгую блокировку \autocite{PgReference1}.
     \item В SQL Server \texttt{TABLOCKX} используется для полной блокировки таблицы \autocite{MicrosoftLearnSQLserverTabHints}.
     \item В Oracle есть режим \texttt{SHARE MODE}, который предотвращает модификации, но разрешает чтение \autocite[ch.18]{oracledbreference}.
 \end{itemize}
 
 \subparagraph{Блокировки строк (Row Lock)} ~\\

 Наиболее гибкий и эффективный вид блокировки: блокируется одна строка в таблице, а не вся таблица целиком. Используется в большинстве современных СУБД с поддержкой многоверсионности (MVCC): PostgreSQL, InnoDB (MySQL), SQLServer.
 Применяется при изменении конкретной записи (\texttt{UPDATE}, \texttt{DELETE}), при параллельном доступе к одной таблице (если одна таблица обновляет строку а другая читает).
 
 Например, команда:
 \begin{lstlisting}[language=SQL]
     SELECT * FROM accounts WHERE id = 5 FOR UPDATE;
 \end{lstlisting}

 Она накладывает блокировку на строку, предотвращая изменение другими транзакции. В Postgre и в MySQL команда одинаковая.

 В SQL Server можно также предотвратить конфликтные обновления с помощью \texttt{\detokenize{WITH (UPDLOCK)}} \autocite{MicrosoftLearnSQLserverTabHints}
 
 \subparagraph{Блокировки индексов (Index Lock)} ~\\

 Блокировки индексов - отдельный вид блокировки, который накладывается не на данные, а на индексы, когда они обновляются. То есть или когда надо избежать конфликтов при пересчете индексов при добавлении новых записей (\texttt{INSERT}), или при обновлении индексов при изменении значений ключевых полей.
 
 Например, если у нас есть \texttt{PRIMARY KEY} или \texttt{UNIQUE} индекс, СУБД проверяет, существует ли уже такое значение. Или если несколько транзакций, одновременно которые пытаются вставить разные строки с одинаковым ключевым значением, тоже возникает конфликт. Например:
 \begin{lstlisting}[language=SQL]
     INSERT INTO users (id, name) VALUES (5, 'Alice');
     INSERT INTO users (id, name) VALUES (5, 'Bob');
 \end{lstlisting}

 В данном случае, во второй строке блокировка индекса, конфликт по PRIMARY KEY. Первый \texttt{INSERT} успешно проходит, а второй будет ждать пока индекс не освободится.
 
 Если обновление записей (\texttt{UPDATE}), затрагивающее индексированные поля, например, если транзакция изменяет значение столбца, который входит в индекс, индекс должен быть обновлен. Это может привести к блокировке, так как надо сначала найти старое значение в индексе а затем заменить его новым.
 \begin{lstlisting}[language=SQL]
     UPDATE users SET id = 10 WHERE id = 5;
 \end{lstlisting}

 Если другая транзакция попробует обновить \texttt{id = 5} в этот же момент, она будет заблокирована до завершения первой.
 
 С удалением записей \texttt{DELETE} то же самое что и с \texttt{UPDATE}.
 
 \subparagraph{Блокировки страниц (Page Lock)} ~\\

 Промежуточный уровень между Row Lock и Table Lock. Применяется, когда необходимо ограничить доступ к группе строк, хранящихся на одной странице в памяти или на диске. Например, когда блокировка всей таблицы избыточна, а построчная блокировка слишком затратная.
 
 Каждая страница в базе данных обычно имеет фиксированный размер (например, 8 КБ в SQL Server и Oracle), и хранит несколько записей. При блокировке страницы все данные внутри неё становятся недоступными для изменений другими транзакциями.
 
 Особенно полезна блокировка страниц в следующих сценариях: при массовых обновлений, когда транзакция обновляет или удаляет большое количество строк, и блокировка каждой строки отдельно весьма накладна, и вместо этого СУБД может заблокировать целую страницу, содержащую эти строки, чтоб минимизировать количество операций блокировки.
 Пример кода:
 \begin{lstlisting}[language=SQL]
     UPDATE Orders
     SET status = 'shipped' 
     WHERE order_date < '2024-01-01';
 \end{lstlisting}

 Если вот эта вот команда затрагивает тысячи записей, то СУБД может применить блокировку страниц, чтобы не блокировать каждую строку отдельно
 
 \paragraph{Классификация блокировок по типу доступа} ~\\
 
 Ключевые типы блокировок включают разделяемые (SHARED, S-LOCK), исключительные (EXCLUSIVE, X-LOCK), блокировки обновления (UPDATE LOCK) и намеренные блокировки (INTENT LOCKS)
 Рассмотрим каждый из них в отдельности.
 
 \subparagraph{1. Разделяемая блокировка (SHARED LOCK, S-LOCK)} ~\\

 S-LOCK позволяет нескольким транзакциям читать одни и те же данные, но запрещает их изменение, пока не будет снята \autocite{ElmasriNavathe}.

 Например, транзакция получает разделяемый доступ, когда выполняется \texttt{SELECT ... FOR SHARE} в PostgreSQL, \texttt{LOCK IN SHARE MODE} в MySQL или аналог в других СУБД.
 Подобная махинация позволяет предотвратить изменения данных в процессе их анализа.
 
 Работает следующим образом: если один пользователь читает строку с S-LOCK, другие пользователи тоже могут ее читать (ставить свои S-LOCK), но если кто-то попытается изменить данные (\texttt{UPDATE}, \texttt{DELETE}), то система заставит его ждать, пока все S-LOCK не будут сняты.
 
 Пример (PostgreSQL):
 \begin{lstlisting}[language=SQL]
     BEGIN;
     SELECT * FROM orders WHERE id = 5 FOR SHARE;    
 \end{lstlisting}

 Этот запрос заблокирует запись \texttt{orders.id =5} от изменений, но другие транзакции все равно смогут ее читать.
 
 Для MySQL это будет выглядеть так:
 \begin{lstlisting}[language=SQL]
     SELECT * FROM orders WHERE id = 5 LOCK IN SHARE MODE;  
 \end{lstlisting}
 
 Проблема тут может возникнуть, если кто-то ждет X-LOCK, а другая транзакция долго держит S-LOCK, тогда возникает долгое ожидание
 
 \subparagraph{2. Исключительная блокировка (EXCLUSIVE LOCK, X-LOCK)} ~\\

 Блокировка полностью запрещает доступ другим транзакциям, то есть другие транзакции не могут ни читать, ни изменять строку, заблокированную X-LOCK, пока блокировка не будет снята.
 
 При \texttt{UPDATE}, \texttt{DELETE}, \texttt{INSERT} СУБД автоматически накладывают X-LOCK на изменяемые строки чтоб никакая другая транзакция не смогла получить доступ к изменяемым данным, пока операция не завершится
 
 То есть в случае (MySQL):
 \begin{lstlisting}[language=SQL]
     UPDATE orders SET status = 'Sent' WHERE id = 5; 
 \end{lstlisting}

 После выполнения UPDATE строка \texttt{orders.id =5} будет автоматически заблокирована X-LOCK и никто не сможет ее читать или менять пока транзакция не завершится.
 
 Когда X-LOCK накладывается на строку, другие транзакции ждут, пока она освободится. Также X-LOCK не конфликтует с самой собой, одна транзакция может сама несколько раз заблокировать одну строку без проблем.
 
 Пример (PostgreSQL):
 \begin{lstlisting}[language=SQL]
     BEGIN;
     SELECT * FROM employees WHERE id = 1 FOR UPDATE;
     SELECT * FROM employees WHERE id = 1 FOR UPDATE;
     COMMIT;    
 \end{lstlisting}

 Тут второй \texttt{FOR UPDATE} (повторный X-LOCK на одну и ту же строку) не приведет к конфликту, потому что оба запроса выполняются в одной транзакции. То есть СУБД распознает, что блокировка уже принадлежит той же транзакции, и просто увеличит счетчик блокировок, а не заблокирует саму себя.
 
 \subparagraph{3. Блокировка обновления (UPDATE LOCK)} ~\\

 Специальный вид блокировки, он предотвращает взаимоблокировки при обновлении данных.
 Например, если какая-то транзакция делает \texttt{SELECT ... FOR UPDATE} и ждет, другая транзакция делает также \texttt{SELECT ... FOR UPDATE} на ту же строку и тоже ждет, то обе транзакции зависают потому что обе ждут снятия блокировки у другой (deadlock). 
 Соответственно \texttt{UPDATE LOCK} предназначен для снижения вероятности deadlock: если транзакция использует \texttt{UPDATE LOCK}, то другие транзакции могут читать данные, но не могут их обновлять.
 
 Пример наложения \texttt{UPDATE LOCK} на \texttt{orders.id=5} (PostgreSQL)
 \begin{lstlisting}[language=SQL]
     SELECT * FROM orders WHERE id = 5 FOR UPDATE;
 \end{lstlisting}
 
 \subparagraph{4. Намеренные блокировки (INTENT LOCKS, I-LOCKS)} ~\\

 В SQL Server для согласованности блокировок между разными уровням данных используются блокировки \texttt{INTENT LOCKS}. \autocite{MicrosoftLearnSQLserverTransLock}
 
 Если транзакция хочет поставить \texttt{X-LOCK} на строку, она сначала должна поставить XI-LOCK (\texttt{INTENT EXCLUSIVE LOCK}) на таблицу. Если она хочет поставить \texttt{S-LOCK} на строку, то сначала она должна поставить \texttt{IS-LOCK} (\texttt{INTENT SHARED LOCK}) на таблицу.
 
 Это нужно, чтобы избежать конфликтов между блокировками разных уровней. Например, если кто-то хочет заблокировать всю таблицу, но есть \texttt{I-LOCK} на отдельные строки, то таблица не заблокируется до освобождения всех строк.
 
 \begin{lstlisting}[language=SQL]
     SELECT * FROM orders WITH (HOLDLOCK);
 \end{lstlisting}
 
 Здесь ставится \texttt{IS-LOCK} на таблицу и \texttt{S-LOCK} на строки.

\paragraph{Эскалация блокировок} ~\\

Количество блокировок, которые может потребоваться установить SQL-запросу, как правило, можно предварительно оценить на основе того, какие операции сканирования реляционных объектов (relation scan) он выполняет. Например, если запрос сканирует всю таблицу, то чаще всего будет установлена блокировка на уровне всей таблицы (relation-level lock). Если же предполагается использовать индексное сканирование для извлечения небольшого количества записей, то может быть установлена намеренная блокировка (intention lock) на уровне таблицы и обычные блокировки на уровне отдельных кортежей (строк). Однако если транзакция начинает захватывать слишком большое количество блокировок на уровне строк, это может привести к переполнению внутренней таблицы блокировок (lock table), которую использует менеджер блокировок для хранения информации о текущих захватах. Чтобы избежать исчерпания ресурсов, менеджер блокировок может выполнить так называемую \textbf{эскалацию блокировок} — замену множества мелких (например, строковых) блокировок одной более крупной, например, блокировкой всей таблицы. \autocites[ch.18]{Silberschatz}

\begin{grayquote}
    \textbf{Эскалация блокировок} - процесс автоматического перевода множества мелких блокировок (например, на уровне строк) в более крупную блокировку (например, всей таблицы или страницы памяти), когда количество мелких блокировок превышает установленный порог. Этот механизм используется чтобы уменьшить накладные расходы на управление блокировками и сэкономить ресурсы системы.
\end{grayquote}

Зачем оно надо?
\begin{itemize}
    \item Снижение затрат ресурсов, поскольку каждая блокировка требует памяти и времени, и если транзакция блокирует тысячи строк, то это может перегрузить менеджер блокировок.
    \item Менеджеру блокировок проще и быстрее принять решение, управляя одной крупной блокировкой, чем многими мелкими.
    \item Эскалация может уменьшить количество конкурентных блокировок и тем самым снизить вероятность взаимоблокировок.
\end{itemize}

Однако такая замена увеличивает вероятность конфликта между транзакциями, так как крупнозернистая блокировка ограничивает параллелизм работы \autocite{MicrosoftLearnSQLserverTransLock}

Как пример, рассмотрим SQL Server. В нем эскалация блокировок инициируется в следующих случаях \autocite{MicrosoftLearnSQLserverTransLock}:
\begin{itemize}
    \item Если один Transact-SQL-запрос получает 5000 или более блокировок на одной таблице (или разделе таблицы).
    \item Если общая память, используемая для блокировок в инстансе SQL Server, превышает определённый порог (например, 24\% от доступной памяти при \texttt{locks = 0}).
    \item Также повторные попытки эскалации выполняются каждые 1250 новых блокировок при условии, что изначальная попытка не удалась.
\end{itemize}

Рассмотрим код:
\begin{lstlisting}[language=SQL]
    BEGIN TRANSACTION;
    UPDATE employees
    SET salary = salary * 1.1
    WHERE department = 'IT';
\end{lstlisting}

Если под условие \texttt{WHERE department = 'IT'} попадает более 5000 строк, SQL Server может инициировать эскалацию, заменив множество \texttt{ROW}-блокировок одной \texttt{TABLE}-блокировкой уровня \texttt{X} (эксклюзивной). Все предыдущие блокировки на строки, страницы и индексы в рамках таблицы \texttt{employees} будут при этом сняты.

Стоит также отметить следующие моменты:
\begin{itemize}
    \item Система не выполняет эскалацию до уровня страниц (только до уровня таблицы).
    \item При успешной эскалации все более мелкие блокировки заменяются одной более крупной.
    \item Если необходимая блокировка таблицы не может быть получена (например, из-за конфликта с другой транзакцией), то \textbf{эскалация не выполняется}, и система продолжает устанавливать мелкие блокировки.
\end{itemize}

Настроить или отключить эту штуку можно через \texttt{ALTER TABLE ... SET (LOCK ESCALATION = ...)}.

Например так:
\begin{lstlisting}[language=SQL]
    ALTER TABLE employees SET (LOCK_ESCALATION = DISABLE);
\end{lstlisting}

\paragraph{Временные блокировки} ~\\

Еще одним из простых, но при этом эффективных механизмов борьбы с зависаниями транзакций является использование тайм-аутов блокировок (lock timeouts). Суть подхода заключается в том, что транзакция, запросившая ресурс, не ждет его бесконечно. Вместо этого система предоставляет ей только ограниченное количество времени на ожидание. Если к этому моменту доступ не предоставлен, транзакция автоматически прерывается и откатывается. \autocite[ch.18]{Silberschatz}

Таймауты блокировок по сути это гибридная стратегия между \textbf{предотвращением взаимоблокировок (deadlock prevention)} (где система проектируется так, чтобы такие ситуации не возникали) и \textbf{обнаружением и устранением взаимоблокировок (deadlock detection and recovery)} (где deadlock'и допускаются, но при этом отслеживаются и устраняются системой).

Когда транзакция сталкивается с невозможностью получить нужный ей ресурс в течение заданного времени, считается что оно зависло либо из-за deadlock'а или из-за длительного ожидания, и выполняется откат (\texttt{ROLLBACK}) транзакции, тем самым освобождая ресурсы и позволяя другим операциям продолжиться.

\begin{grayquote}
    \textit{<<Если транзакция ожидает блокировку дольше допустимого времени, она откатывается. Это снижает вероятность зацикливания и помогает системе быстрее восстановиться при взаимоблокировке>>} \autocite[ch.18]{Silberschatz}
\end{grayquote}

К плюсам подобного подхода следует отнести простоту реализации, эффективность при коротких транзакциях, а также автоматическую очистку зависших операций.
Из минусов - требуется точная настройка времени ожидания. Слишком короткий таймаут приведет к излишним rollback'ам даже без deadlock, а слишком длинный задержит обнаружение реальной проблемы. \autocite[ch.22]{ElmasriNavathe}

В PostgreSQL можно задать максимальное время ожидания блокировки при помощи параметра \texttt{lock\_timeout} \autocite[§19.11]{PostgreSQLdocc19}:
\begin{lstlisting}[language=SQL]
    SET lock_timeout = '2s';
    BEGIN;
    UPDATE employees SET salary = salary + 1000 WHERE id = 1;
    COMMIT;
\end{lstlisting}

Здесь установлено максимум 2 секунды ожидания блокировки, и дальше идет попытка обновить строку которая уже заблокирована другой транзакцией. И если строка \texttt{id = 1} заблокирована другой транзакцией, и блокировка не освобождается в течение 2 секунд, то тогда PostgreSQL автоматически выдаст ошибку и откатит текущую транзакцию:

\begin{lstlisting}[language=]
    ERROR: canceling statement due to lock timeout
\end{lstlisting}

В MySQL параметр \texttt{innodb\_lock\_wait\_timeout} (по умолчанию 50 секунд) задает максимальное время ожидания блокировки. Превышение лимита вызывает откат транзакции с ошибкой \texttt{Lock wait timeout exceeded} \autocite[§17.14]{Mysqldoc4}.

В SQL Server оператор \texttt{SET LOCK\_TIMEOUT} \autocite{MicrosoftLearnSQLserverSetLockTout} задает время ожидание \textbf{в миллисекундах} (1000 мс = 1с):
\begin{lstlisting}[language=SQL]
    SET LOCK_TIMEOUT 2000;
    BEGIN TRANSACTION;
    UPDATE employees SET salary = salary + 1000 WHERE id = 1;
    COMMIT;
\end{lstlisting}

Если таймаут превышен, возникает ошибка:
\begin{lstlisting}[language=]
    Msg 1222, Level 16, State 51
    Lock request time out period exceeded.    
\end{lstlisting}


\subsubsection{Протоколы блокировок}

Протоколы управления блокировками - это набор правил и/или алгоритмов, которые регулируют порядок захвата и освобождения блокировок транзакциями. Основная их цель - обеспечить согласованности данных, предотвратит аномалии возникающие при параллельном доступе и гарантировать сериализуемость (то есть такую историю выполнения транзакций которая эквивалент их некоторому последовательному (однопотопному) выполнению).
Наиболее самым широко используемый это двухфазный протокол блокировок (2PL) который обеспечивает корректное взаимодействие транзакций путем строго регламентированной последовательности блокировок и освобождения. Однако его использование может привести к \texttt{deadlocks}.


\paragraph{Двухфазный протокол блокировок (2PL)} ~\\

Двухфазный протокол блокировок (Two-Phase Locking, 2PL) - один из наиболее известных и широко используемых протоколов управления параллелизмом транзакций в реляционных СУБД. Основная задача протокола - обеспечить сериализуемость, то есть согласованное выполняемое транзакции в много пользовательской среде, исключая нежелательные аномалии доступа к данных.

Протокол 2PL делит жизненный цикл транзакции на две чётко разграниченные фазы \autocite[ch.18 §1.3]{Silberschatz}:

\begin{enumerate}
    \item Фаза захвата (growing phase) - транзакция может только запрашивать новые блокировки, но не может снимать уже полученные
    \item Фаза освобождения (shrinking phase) - транзакция может только освобождать блокировки, но не может запрашивать новые
\end{enumerate}

Как только транзакция начинает снимать хотя бы одну блокировку то она переходит из фазы захвата в фазу освобождения и теряет возможность получать новые блокировки, и это правило строго ограничивает поведение транзакции и обеспечивает корректное взаимодействие с другими транзакциям (делает поведение транзакции предсказуемым \textrightarrow исключает аномалии которые могли бы возникнуть при произвольном порядке захвата и снятия блокировок). \autocites[ch.18 §1.3]{Silberschatz}[ch.22 §1.2]{ElmasriNavathe}

Основной идеей протокола 2PL является то, что все необходимые блокировки должны быть получены до начала их освобождения. Таким образом блокировки накладываются как бы в <<в рост>>, а затем <<спадают>>. Это приводит к тому что вся работа с данными (и потенциальные конфликты) контролируются до того как транзакция начнет отпускать ресурсы. Это обеспечивает изоляцию и согласованность. \autocite[ch.18 §1.3]{Silberschatz}

Рассмотрим конкретную ситуацию в которой участвуют две транзакции T1 и T2, обе работающие с двумя объектами A и B:
\begin{table}[H]
    \centering
    \begin{tabular}{|p{7cm}|p{7cm}|}
        \hline
        \textbf{Транзакция T1} & \textbf{Транзакция T2} \\
        \hline
        \begin{lstlisting}[language=SQL]
            LOCK A;
            READ A;
            LOCK B;
            WRITE B;
            UNLOCK B;
            UNLOCK A;
        \end{lstlisting}
        &
        \begin{lstlisting}[language=SQL]
            LOCK B;
            READ B;
            LOCK A;
            WRITE A;
            UNLOCK A;
            UNLOCK B;
        \end{lstlisting} \\
        \hline
    \end{tabular}
    \caption{Параллельное выполнение транзакций с конфликтом блокировок}
    \label{tab:conflict_transactions}
\end{table}
    
То есть T1 сначала захватывает \texttt{A}, а затем \texttt{B}. T2 сначала захватывает \texttt{B}, затем пытается захватить \texttt{A}.
В этой ситуации возможна взаимоблоировка: T1 удерживает \texttt{A} и ждет \texttt{B}, T2 удерживает \texttt{B} и ждет \texttt{A}.

Каждая транзакция <<держит>> один ресурс и <<ждёт>> другой, что создает циклическую зависимость (\texttt{deadlock}).
Однако важно отметить, что не смотря на возможность deadlock'ов, протокол 2PL гарантирует сериализуемость, то есть даж если необходимость отката или ожидания, порядок операций будет согласован с некоторой последовательной историей выполнения.

\subparagraph{Ключевые правила перехода между фазами} ~\\

 В момент транзакцией совершения хотя бы одной блокировки, она считается перешедшей во вторую фазу - и на всегда теряет возможность захвата новых блокировок. Любая попытка получить блокировку в фазе освобождения считается нарушение 2PL-протокола.
 Это приводить к следящим последствиям:
 \begin{itemize}
    \item Транзакции обязаны планировать блокировки заранее
    \item После начала освобождения ресурсов поведение становится только освобождающим
    \item Эти моменты исключают повторные захваты, и тем самым типа делает поведение транзакции безопасно с точки зрения изоляции \autocite[ch.22]{ElmasriNavathe}
 \end{itemize}

\subparagraph{Решение проблемы взаимоблокировок} ~\\

 СУБД обычно решают проблему взаимоблокировок одним из следующих образов \autocite{Silberschatz}:
 \begin{enumerate}
    \item detection\&recovery - построение графа ожидания и прерывание одной из транзакций
    \item prevention - навязывание порядка захвата ресурсов дабы исключить циклы
    \item таймауты (прерывание транзакции если она ждет слишком долго)
 \end{enumerate}

 \paragraph{Вариации двухфазного протокола} ~\\

 Протокол 2PL имеет несколько вариаций: строгий и серьезный
 
 \subparagraph{Строгий двухфазный протокол блокировок (Strict 2PL)} ~\\

 Strict Two-Phase Locking Protocol это наи более часто применяемый на практике вариант, который обеспечивает как сериализуемость так и восстанавливаемость транзакций
 
 \begin{grayquote}
     В Strict 2PL транзакция не освобождает ни одной эксклюзивной блокировки (X) до тех пор, пока не выполнен COMMIT или ROLLBACK \autocite{Silberschatz}
 \end{grayquote}
 
 При этом блокировки на чтение (S - shared) могут быть освобождены до завершения транзакции.
 
 Пример:
 Допустим, транзакция обновляет таблицу:
 \begin{lstlisting}[language=SQL]
     BEGIN;
     UPDATE accounts SET balance = balance - 100 WHERE id = 1;
     COMMIT;    
 \end{lstlisting}

 До выполнения \texttt{COMMIT} ни одна другая транзакция не сможет прочитать или изменить эту строку, поскольку транзакция все еще удерживает эксклюзивную блокировку до момента \texttt{COMMIT}
 
 Из плюсов: гарантия сериализуемости и обеспечение восстанавливаемости, так как ни какая другая транзакция не сможет прочитать <<грязные>> неподтвержденные данные
 
 \subparagraph{Серьезный двухфазный протокол блокировок (Rigorous 2PL)} ~\\

 Rigorous Two-Phase Locking Protocol это ещё более ограничительная версия, чем strict 2PL \autocite{Silberschatz}
 \begin{grayquote}
     В Rigorous 2PL ни одна блокировка (ни shared, ни exclusive) не освобождается до конца транзакции. 
     То есть, как блокировки на чтение (S), так и на запись (X) держатся до \texttt{COMMIT} или \texttt{ROLLBACK}. \autocite{Silberschatz}
 \end{grayquote}
 
 \begin{table}[H]
     \centering
     \begin{tabular}{|l|c|c|c|}
         \hline
         \textbf{Характеристика} & \textbf{Обычный 2PL} & \textbf{Strict 2PL} & \textbf{Rigorous 2PL} \\
         \hline
         Гарантия сериализуемости & Да & Да & Да \\
         \hline
         Гарантия восстанавливаемости (recoverability) & Нет & Да & Да \\
         \hline
         Чтение <<грязных>> данных (dirty reads) возможно? & Да & Нет & Нет \\
         \hline
         Отпускание S-блокировок до COMMIT & Да & Да & \textbf{Нет} \\
         \hline
         Отпускание X-блокировок до COMMIT & Да & \textbf{Нет} & \textbf{Нет} \\
         \hline
         Частота взаимоблокировок & Низкая & Средняя & Высокая \\
         \hline
         Простота реализации & Высокая & Средняя & Средняя \\
         \hline
     \end{tabular}
     \caption{Сравнение вариантов двухфазного протокола блокировок}
 \end{table}
 
 \paragraph{Протоколы предотвращения взаимоблокировок (Deadlock Prevention Protocols)} ~\\
 
 В СУБД, использующих блокировки, логично что всегда существует риск возникновения взаимоблокировок (deadlock). Напомним, что это ситуация когда несколько транзакций ждут друг друга и ни одна не может продолжит выполняться. Один из подходов к решение этой проблемы - предотвращение взаимоблокировок заранее, до того как они возникнут.
 
 Для этого применяются специальные протоколы предотвращения взаимоблокировок, которые основаны на управлении порядком получения блокировок и решениях о \texttt{ROLLBACK}. \autocite{Silberschatz, ElmasriNavathe}
 
 \subparagraph{1. Протокол Wait-Die} ~\\

 Wait-Die — неконсервативный протокол предотвращения взаимоблокировок, который использует временные метки транзакций и применяет стратегию <<ждать или сдохнуть>> (wait or die)
 
 Каждая транзакция при старте получает уникальную временную метку, определяющую её <<возраст>> (чем раньше началась транзакция — тем она <<старше>>).
 
 Когда транзакция \texttt{T\_i} хочет захватить блокировку, уже удерживаемую другой транзакцией \texttt{T\_j}, система сравнивает их возраст \autocite{Silberschatz, ElmasriNavathe}:
 \begin{itemize}
     \item Если \texttt{T\_i} старше чем \texttt{T\_j} (то есть \texttt{T\_i.timestamp < T\_j.timestamp}), то \texttt{T\_i} ожидает (wait)
     \item Если же \texttt{T\_i} младше \texttt{T\_j}, то \texttt{T\_i} немедленно откатывается (die/rollback)
 \end{itemize}
 
 Пример:
 Пусть у транзакции \texttt{T1} временная метка =10, у \texttt{T2} - 20. Пусть \texttt{T1} удерживает блокировку на \texttt{A}. \texttt{T2} хочет захватить \texttt{A}, но она моложе, поэтому \texttt{T2\textrightarrow ROLLBACK}. Если наоборот \texttt{T1} хочет захватить объект, заблокированный \texttt{T2}, то она ждет.
 
 То есть это простой в реализации протокол, но он может вызывать частные откаты младших транзакций.
 
 \subparagraph{2. Протокол Wound-Wait} ~\\

 Wound-Wait — альтернативный протокол, тоже использующий временные метки, но с другой логикой <<ранить или ждать>>
 
 Идея протокола \autocite{Silberschatz, ElmasriNavathe}:
 \begin{itemize}
     \item Если \texttt{T\_i} старше \texttt{T\_j}, то \texttt{T\_i} <<ранит>> \texttt{T\_j} (wound)
     \item Если \texttt{T\_i} младше \texttt{T\_j}, то оно ждет, пока \texttt{T\_j} не освободит ресурс (wait)
 \end{itemize}
 
 Пример:
 \texttt{T1} старше, \texttt{T2} моложе. \texttt{T2} захватила \texttt{B}, \texttt{T1} хочет тоже. \texttt{T1} старше\textrightarrow \texttt{T1} <<ранит>> \texttt{T2}\textrightarrow \texttt{T2\textrightarrow ROLLBACK} 
 
 Более агресивен, чем Wait-Die в плане прерывания работы <<младших>>, позволяет старым транзакциям быстрее завершаться.
 
 \begin{table}[H]
     \centering
     \caption{Сравнение протоколов Wait-Die и Wound-Wait}
     \begin{tabular}{|l|p{5.25cm}|p{5.25cm}|}
         \hline
         \textbf{Характеристика} & \textbf{Wait-Die} & \textbf{Wound-Wait} \\
         \hline
         Тип решения & Транзакция ожидает или откатывается & Транзакция откатывает другого или ждёт \\
         \hline
         Кто откатывается & Молодая транзакция & Молодая транзакция \\
         \hline
         Поведение при конфликте & Старшая ждёт, младшая откатывается & Старшая прерывает младшую \\
         \hline
         Вероятность откатов & Средняя & Высокая (более агрессия) \\
         \hline
         Подходит для & Транзакций с длительным временем ожидания & Высокоприоритетных (старших) транзакций \\
         \hline
     \end{tabular}
 \end{table}
 
 \subparagraph{Консервативный подход (Conservative 2PL)} ~\\

 Оба вышеперечисленных рассмотренных протокола относятся к неконсервативным, потому что позволяют транзакциям захватывать блокировки по мере необходимости, хотя и с контрольной логикой.
 
 Консервативный подход же заключается в следующем \autocite{Silberschatz, ElmasriNavathe}:
 \begin{itemize}
     \item Транзакция сначала запрашивает ВСЕ необходимые блокировки прежде чем начать выполнение
     \item Если ец не удалось получить все блокировки, то она ожидает ничего не делая
     \item Исключает deadlock \textbf{полностью}
 \end{itemize}
 
 \begin{table}[H]
     \centering
     \caption{Сравнение консервативного и неконсервативных протоколов}
     \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
         \hline
         \textbf{Характеристика} & \textbf{Консервативный 2PL} & \textbf{Wait-Die / Wound-Wait} \\
         \hline
         Подход & Захват всех блокировок сразу & Захват по мере необходимости \\
         \hline
         Гарантия отсутствия взаимоблокировки & Да & Да (по алгоритму) \\
         \hline
         Гибкость & Низкая & Высокая \\
         \hline
         Параллелизм & Низкий & Выше \\
         \hline
         Откаты & Отсутствуют & Возможны \\
         \hline
         Реализация & Требует знания всех блокировок ресурсов заранее & Проще реализовать \\
         \hline
     \end{tabular}
 \end{table}
     
 \begin{table}[H]
     \centering
     \caption{Преимущества и недостатки протоколов предотвращения взаимоблокировок}
     \begin{tabular}{|l|p{6cm}|p{6cm}|}
         \hline
         \textbf{Протокол} & \textbf{Преимущества} & \textbf{Недостатки} \\
         \hline
         Wait-Die & Простота реализации, предотвращение deadlock & Частые откаты у младших транзакций \\
         \hline
         Wound-Wait & Приоритет старших транзакций, быстрое завершение приоритетных операций & Агрессивная политика, возможные <<жесткие>> откаты \\
         \hline
         Консервативный 2PL & Исключение взаимоблокировок, логическая простота & Слабый параллелизм, неэффективен при заранее неизвестных ресурсах \\
         \hline
     \end{tabular}
 \end{table}
    
\paragraph{Протоколы меток времени (Timestamp-Based Protocols)} ~\\

Протоколы управления параллелизмом, основанные на метках времени (timestamp-based protocols) представляют собой альтернативу протоколам блокировок. В отличие от двухфазной блокировки (2PL), где порядок операций определяется во время исполнения, здесь порядок транзакций устанавливается заранее на основе уникальных временных меток, назначаемых каждой транзакции до её начала.

Каждой транзакции $T_i$ до начала выполнения назначается уникальный timestamp $TS(T_i)$ — числовое значение, отражающее <<момент появления>> транзакции в системе. Timestamp можеит быть сгенерирован двумя способами \autocite[ch.18 §5]{Silberschatz}:
\begin{enumerate}
    \item На основе \textbf{значения системных часов} в момент начала транзакции (например значение в миллисекундах с начала эпохи Unix)
    \item С помощью глобального \textbf{счетчика}, который увеличивается при каждой новой транзакции 
\end{enumerate}

Метки времени определяют сериализуемый порядок транзакций, типа если $TS(T_i) < TS(T_j)$, то транзакция $TS(T_i)$ должна предшествовать $TS(T_j)$ в расписании.

Например, пусть в систему вошли транзакции $T_1$, $T_2$, $T_3$, и получили метку времени $TS(T_1) = 100, TS(T_2) = 105, TS(T_3) = 110$. Тогда теперь СУБД должна гарантировать что в итоговом исполнении порядок транзакций будет эквивалентен такому последовательности: $T_1 \rightarrow T_2 \rightarrow T_3$.

\subparagraph{Метки времени для данных} ~\\

Для реализации протокола с метками времени, каждая запись (объект данных) $Q$ должна хранить два значения:

\begin{itemize}
    \item $W_{\text{timestamp}}(Q)$ - максимальный timestamp среди всех транзакций, успешно выполнивших запись в $Q$
    \item $R_{\text{timestamp}}(Q)$ - максимальный timestamp среди всех транзакций, успешно выполнивших чтение из $Q$
\end{itemize}


Эти значения обновляются каждый раз, когда с объектом данных происходит операция чтения или записи. Они позволяют системе проверить не нарушит ли новая операция установленный порядок.

\subparagraph{Timestamp Ordering Protocol} ~\\

Протокол гарантирует что все конфликтующие операции выполняются в порядке меток времени. Суть протокола в том, что каждая операция транзакции проверяется на допустимость в соответствии с ее меткой времени и состоянием данных. Протокол работает следующим образом \autocite{Silberschatz}:

\begin{itemize}
    \item Если транзакция $T_i$ выполняет операцию чтения (\texttt{read($Q$)})
    \begin{itemize}
        \item Если $TS(T_i) < W_{\text{timestamp}}(Q)$, значит что транзакция пытаться прочитать значение которое уже было перезаписано более новой транзакцией, а следовательно чтении старой версии недопустимо и операция отклоняется а $T_i$ откатывается (\texttt{ROLLBACK})
        \item В противном случае выполняется чтение, а $R_{\text{timestamp}}(Q)$ обновляется до $max(R_{\text{timestamp}}(Q), TS(T_i))$
    \end{itemize}

    \item Если транзакция $T_i$ выполняет операцию записи (\texttt{write($Q$)})
    \begin{itemize}
        \item Если $TS(T_i) < R_{\text{timestamp}}(Q)$, значит что уже была транзакция которая прочитала <<новое>> (<<будущее>>) значение и операция отклоняется а $T_i$ откатывается (\texttt{ROLLBACK})
        \item Если $TS(T_i) < W_{\text{timestamp}}(Q)$, то $T_i$ пытается записать устаревшее значение (на данный момент кто-то уже записал в $Q$ новое значение) - также откат
        \item В противном случае запись выполняется, и $W_{\text{timestamp}}(Q)$ обновляется до $TS(T_i))$ 
    \end{itemize}
\end{itemize}

При этом транзакция, которая была откатана, получает новый timestamp и повторяется.

Пример. Рассмотрим две транзакции:
\begin{itemize}
    \item $T_1$ показывает сумму на счетах $A$ и $B$:
    \begin{lstlisting}[language=SQL]
        read(B);
        read(A);
        display(A + B);           
    \end{lstlisting}

    \item $T_2$ переводит 50 условных единиц со счета $B$ на счет $A$:
    \begin{lstlisting}[language=SQL]
        read(B);
        B := B - 50;
        write(B);
        read(A);
        A := A + 50;
        write(A);
        display(A + B);               
    \end{lstlisting}
\end{itemize}

Если $TS(T_1) < TS(T_2)$, то протокол допускает выполнение всех операций в этом порядке. Но в ситуации где операции пересекаются и нарушают порядок по меткам времени (например $T_2$ начнет изменять данные прочитанные $T_1$ до завершения $T_1$ \textrightarrow возможен конфликт), одна из транзакций ($T_2$) будет откатана. Дабы обеспечить конфликтную сериализуемость.

\subparagraph{Преимущества и недостатки} ~\\

Плюсы:
\begin{itemize}
    \item Отсутствие deadlock - никакая транзакция не ждет ресурс, так как при конфликте приходит откат
    \item Гарантирована сериализуемость
\end{itemize}

Минусы:
\begin{itemize}
    \item Возможность <<голодания>> (starvation), так как длинная транзакция может много раз откатываться из-за коротких конфликтующих транзакций
    \item Слишком много откатов может привести к проблемам с производительностью
    \item Необратимость (при записи может быть трудно реализовать cascadeless или recoverable свойства без доп. механизмов) \autocite{Silberschatz}
\end{itemize}

Чтобы обеспечить recoverability (восстанавливаемость) и избежать каскадных откатов можно \autocite{Silberschatz, ElmasriNavathe}:
\begin{itemize}
    \item Можно откладывать запись в базу до завершения всех операций (так называемый deferred write)
    \item Можно применять ограниченные блокировки на записи чтоб предотвратить чтение неисправленных данных
    \item Можно использовать commit dependencies (зависимости фиксации) - транзакция может быть зафиксирован только после фиксации другой от которой она зависит
\end{itemize}

\subparagraph{Пролема фантомов} ~\\

Предикатный запрос - это SQL-запрос, выбирающий не конкретные строки по первичному ключу, а множество строк по заданному условию. Примеры:
\begin{lstlisting}[language=SQL]
    SELECT * FROM employees WHERE salary > 100000;
    SELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-03-01';       
\end{lstlisting}

Теперь представим что одна транзакция $T_1$ выполняет такой запрос, а другая транзакция $T_2$ вставляет новую строку которая удовлетворяет тому же условию. Если $T_1$ повторит запрос в рамках своей-же транзакции то она увидит новую строку, которой не было ранее, и это нарушит изоляцию. Это явление называется \textbf{фантомным чтением (phantom read)}

Классический протокол управления параллелизмов на основе меток времени контролирует последовательность операций только на уровне кортежей (tuples). То есть проверяются конфликты между отдельными строками, а не между какими-то множествами строк выбранными по предикату.

То есть система может не знать что изменение (вставка, удаление) новой строки затрагивает предикат уже выполненного запроса в другой транзакции. В результате транзакция может дважды выполнить оин и тот же предикатный запрос и получить разные результаты (аномалия фантома), и при этом никаких явныхх конфликтов чтения/записи отдельных строк не произойдет, и система это не заметит.

Ограничение здесь - только кортежи. Протокол, как ранее было описано, отслеживает два значения - $W_{\text{timestamp}}(Q)$ и $R_{\text{timestamp}}(Q)$ для каждого объекта $Q$. Если $Q$ - это строка таблицы, то все управление конфликтами сводится к строкам. Но предикатные запросы потенциально работают и со всем множеством строк, которые еще не существуют, и timestamp-протокол просто не может их учесть пока они не будут вставлены - и это его принципиальное ограничение.

Чтобы избежать фантомов, надо учитывать не только tuples, но и структуру таблицы в целом и еще индексные узлы. Почему?
Потому что предикатный запрос фактически взаимодействует с следующим:
\begin{itemize}
    \item множество строк которые удовлетворяют условию
    \item интервалы значений, которые проверяются (например \texttt{WHERE salary $>$ 100000} — это диапазон)
    \item индексы, которые используются для ускорения поиска
\end{itemize}

В протоколах блокировок (типа 2PL) эта проблема решается путём блокировки интервалов в индексах (index-range locking). Аналогично и в timestamp-протоколе: если распространить метки времени на индексные страницы, можно отслеживать изменения предикатных множеств \autocite{Silberschatz, ElmasriNavathe}

\subsubsection{Управление блокировками в СУБД}
\paragraph{1. Архитектура управления блокировками} ~\\

Современные СУБД предъявляют высокие требования к параллельно обработке данных и целостности информации. Именно в связи с этим одним из главных компонентов большинства СУБД является \textbf{менеджер блокировок (Lock Manager)} \autocite{Silberschatz}. Он отвечает за согласование доступа к данным между транзакциями и предотвращение конфликтов.

\subparagraph{Lock Table - таблица блокировок} ~\\

 Lock Manager поддерживает специальную внутреннюю структуру данных - \textbf{таблицу блокировок (lock table)}, которая хранит информацию о текущим состоянии блокировок. Каждая запись в таблице блокировок хранит следующие вещи:
 \begin{itemize}
     \item Ресурс (resource) — объект, к которому применяется блокировка (строка, страница, таблица и т.п.)
     \item Идентификатор транзакции (transaction ID) — та транзакция, которая удерживает или ожидает блокировку
     \item Тип блокировки (S (shared), X (exclusive), IS, IX и т.д)
     \item Состояние (активна ли блокировка или транзакция находится в очереди ожидания)
 \end{itemize}
 То есть lock table это является <<центральным реестром>> всех блокировок (активных и ждущих) который постоянно обновляется по мере выполнения транзакций.

\subparagraph{Структуры данных: хеш-таблицы и списки ожидания} ~\\

 Для эффективного поиска блокировок по идентификатору ресурса или транзакции большинство СУБД используют хеш-таблицы. Например, в PostgreSQL используется механизм хеширования lock-tag'ов (уник. идентификаторов блокировок), где каждый тег состоит из информации о типе ресурса, объекте и контексте (например таблица+строка+БД).
 
 Для обработки ситуаций когда несколько транзакций претендуют на один и тот же ресурс, менеджер ожидания использует \textbf{очереди ожидания (wait queues)}. Каждая запись в очереди содержит ссылку на транзакции, ожидаемую блокировку, режим блокировки. И сразу как только ресурс освобождается, менеджер проверяет какие из ожидающих транзакций могут быть разблокированы в соответствии с таблицей совместимости (см. далее).

\subparagraph{Таблица совместимости блокировок} ~\\

 Чтобы определить можно ли выдать блокировку новой транзакции, Lock Manager использует \textbf{таблицу совместимости блокировок (lock compatibility matrix)}. Эта таблица содержит информацию о допустимости наложения разных типов блокировок на один и тот же ресурс (какие блокировки могут быть установлены одновременно). Таблица совместимости блокировок выглядит следующим образом \autocite{Silberschatz}:
 
 \begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \textbf{Запрос / Установлена} & \textbf{IS} & \textbf{IX} & \textbf{S} & \textbf{SIX} & \textbf{X} \\
        \hline
        \textbf{IS} & Да & Да & Да & Да & Нет \\
        \hline
        \textbf{IX} & Да & Да & Нет & Нет & Нет \\
        \hline
        \textbf{S} & Да & Нет & Да & Нет & Нет \\
        \hline
        \textbf{SIX} & Да & Нет & Нет & Нет & Нет \\
        \hline
        \textbf{X} & Нет & Нет & Нет & Нет & Нет \\
        \hline
    \end{tabular}
    \caption{Матрица совместимости блокировок}
 \end{table}

 Каждая строка — это тип запрашиваемой блокировки, а каждый столбец — это тип уже установленной блокировки.
 На основании этой таблицы менеджер блокировок решает либо выдать блокировку немедленно, либо поставить транзакцию в очередь ожидания.
 
 То есть, исходя из таблицы, если на объекте уже стоит \texttt{IS}, то можно установить \texttt{S}. Если на объекте стоит \texttt{S}, то нельзя установить \texttt{X}.

 Рассмотрим назначение комбинированной блокировки \texttt{SIX}:
 \texttt{SIX} (Shared and Intention Exclusive) - комбинированный режим который одновременно удерживает разделяемую блокировку на уровне узла (например таблицы), и заявляет, что будут эксклюзивные блокировки ниже (например на строках).
 \begin{lstlisting}[language=SQL]
    LOCK TABLE employees IN SHARE MODE;
    UPDATE employees SET salary = salary + 1000 WHERE department = 'IT';   
 \end{lstlisting}

 Первая строка - \texttt{S} или \texttt{SIX}, вторая - \texttt{X} на строках. 
 Чтобы не накладывать \texttt{S} \+ \texttt{IX} одновременно (что не совместимо с \texttt{S} другой транзакции), используется \texttt{SIX} как оптимизированный и безопасный способ

\subparagraph{Хеш-функции и внутренние идентификаторы} ~\\

 В PostgreSQL для управления блокировками используется структура LOCKTAG, которая уникально идентифицирует каждый блокируемый объект. Эта структура включает в себя поля \texttt{locktag\_field1}, \texttt{locktag\_field2}, \texttt{locktag\_field3}, \texttt{locktag\_field4}, \texttt{locktag\_type}, \texttt{locktag\_lockmethodid} \autocite{PostgreSQLlockh1, PostgreSQLlockh2}
 Эти поля позволяют идентифицировать различные объекты. Тип объекта определяется полем \texttt{locktag\_type}, которое может принимать значения из перечисления \texttt{LockTagType}, например \texttt{LOCKTAG\_RELATION} для всей таблицы или \texttt{LOCKTAG\_TUPLE} для конкретной строки.
 
 Для управления блокировками PostgreSQL использует хеш-таблицы. Функция \texttt{LockTagHashCode} вычисляет хеш-код для заданного \texttt{LOCKTAG} и позволяет быстро находить и устанавливать блокировки. Этот хеш-код используется для определения раздела хеш-таблицы, в котором хранится информация о блокировке. \autocite{PostgreSQLlockc1, PostgreSQLlockc2}

\paragraph{2. Поддержка блокировок в различных СУБД} ~\\

 Разные системы управления базами данных реализуют механизм блокировок и конкурентный доступ по-разному. Ниже приведены особенности нескольких популярных СУБД: 
 \begin{itemize}
    \item \textbf{PostgreSQL} \autocite{PostgreSQLdocc52} ~\\
    В PostgreSQL для обеспечения согласованности данных применяется многоверсионное управление конкурентностью (MVCC), что минимизирует необходимость блокировок при чтении данных. Каждая транзакция читает данные из последовательной <<снимка>> базы, благодаря чему запросы (чтения) не блокируют операции записи, и наоборот – записи не блокируют чтения. Таким образом достигается высокая параллельность без грязных чтений. Тем не менее, PostgreSQL поддерживает и блокировки на уровне таблиц и строк (например, \texttt{SELECT ... FOR UPDATE}) для случаев, когда требуется принудительная блокировка объектов. Существуют различные режимы блокировок (например, shared/exclusive, Row Share, Row Exclusive и т.д.), а также раздельные механизмы блокировок для таблиц, строк, страниц и пр. – их текущее состояние можно наблюдать через системное представление \texttt{pg\_locks}, где каждая строка показывает объект блокировки, режим и признак удержания/ожидания. Однако при правильном использовании MVCC необходимость ручных блокировок минимальна, это обычно дает лучшее быстродействие по сравнению с явными блокировками
    \item \textbf{Oracle} \autocites{oracledbdoc5, oracleessentialsc7} ~\\
    Oracle Database также использует многоверсионную модель согласованности данных. Чтения по умолчанию не требуют блокировок: при выполнении запроса Oracle предоставляет консистентный снимок данных с помощью механизма \textit{undo} (откатных сегментов), содержащего предшествующие версии изменённых строк. Таким образом, чтение данных не блокируется пишущими транзакциями – вместо этого читатель получает прежнее значение данных из undo-сегмента, если актуальная версия еще не зафиксирована. В результате транзакции в Oracle обычно не сталкиваются с ситуацией, когда чтение мешает записи (исключение – явный запрос \texttt{SELECT \ldots FOR UPDATE}, который устанавливает блокировку на строку). Для изменений данных Oracle ставит эксклюзивные блокировки на затронутые строки, однако не блокирует остальные строки таблицы. В отличие от некоторых СУБД, Oracle не выполняет \textit{эскалацию блокировок} – даже если транзакция заблокировала очень много строк таблицы, эти блокировки не преобразуются принудительно в блокировку всей таблицы. Это возможно благодаря тому, что сведения о блокировках строк хранятся прямо в блоках данных (в специальной области заголовка блока), а не в общей таблице блокировок, поэтому удержание тысяч строковыми блокировками не приводит к чрезмерным накладным расходам и не требует укрупнения до уровня таблицы. Oracle поддерживает уровни изоляции Read Committed (по умолчанию) и Serializable, при этом даже в режиме Serializable читающие транзакции используют многоверсионность для предотвращения конфликтов (феномены <<неповторяемого чтения>> и <<фантомов>> устраняются за счет версионности и специальных механизмов распознавания конфликтов сериализации). Для мониторинга блокировок Oracle предоставляет представления \texttt{V\textdollar LOCK} и \texttt{V\textdollar LOCKED\_OBJECT}, где видны активные блокировки (тип блокировки TM – блокировка на таблицу, TX – блокировка транзакции и т.д.) и запросы на блокировки
    \item \textbf{Microsoft SQL Server} \autocites{oracleessentialsc7, MicrosoftLearnSQLserverTransLock, sqlhack1} ~\\
    В SQL Server исторически используется классический менеджер блокировок, поддерживающий блокировки разных уровней гранулярности: строчные, страничные, табличные и др. По умолчанию (на уровне изоляции Read Committed) чтения блокируют записи (shared-блокировки на время чтения) и записи блокируют чтения (exclusive-блокировки на время изменения данных) для обеспечения изоляции. СУБД динамически выбирает уровень блокировки (строка/страница/таблица) и может автоматически выполнять \textit{эскалацию блокировок} – например, если транзакция удерживает очень много блокировок строк, SQL Server может повысить их до одной блокировки всей таблицы, чтобы снизить накладные расходы на отслеживание большого числа блоков (Oracle, как указано выше, этого не делает). Менеджер блокировок в SQL Server также реализует специальные режимы блокировок: помимо Shared (S) и Exclusive (X) существуют Update-lock (U) – предназначенная для случаев обновления через чтение, чтобы предотвратить взаимоблокировки при последующем повышении уровня блокировки; а также \textit{намерения} блокировок (Intent locks). Намерения (Intent Shared/Exclusive, IS/IX) – это служебные метки на более высоком уровне (например, таблица), сигнализирующие о том, что транзакция планирует блокировать отдельные строки или страницы в режиме Shared или Exclusive соответственно. Механизм намеренных блокировок позволяет SQL Server быстро проверять, можно ли установить блокировку на весь объект, не просматривая все мелкие блокировки: достаточно увидеть наличие IX/IS на таблице, чтобы понять, что объект уже частично заблокирован, и тем самым избежать дорогостоящей проверки каждой строки или страницы. Начиная с версии SQL Server 2005, СУБД поддерживает многоверсионность в виде режимов изоляции Read Committed Snapshot и Snapshot Isolation: при их включении для чтения данных используются версионные копии (в TempDB), что позволяет чтениям не блокировать записи (аналогично принципу Oracle/Postgres). При использовании же стандартного Read Committed без версионности движок полагается на короткие shared-блокировки на время чтения строк. Администратор SQL Server может наблюдать текущие блокировки через системные представления динамического управления, такие как \texttt{sys.dm\_tran\_locks}, а также видеть, какие сессии блокируют друг друга (например, представление \texttt{sys.dm\_exec\_requests} содержит информацию о текущих ожиданиях и блокирующих спидах). Для реагирования на конфликты SQL Server предоставляет настройку \texttt{LOCK\_TIMEOUT}, позволяющую задать максимальное время ожидания блокировки, а при превышении – прерывать запрос.
    \item \textbf{MySQL/InnoDB} \autocite{Mysqldoc4} ~\\
    Всем известная СУБД MySQL (с движком InnoDB) также поддерживает блокировки на уровне строк и таблиц, однако для конкурентного доступа она активно использует MVCC. InnoDB хранит старые версии изменённых строк в специальных undo-табличных пространствах (rollback segments), аналогично Oracle, и при чтении обеспечивает \textit{консистентное не блокирующее чтение (consistent non-locking read)} старых версий данных. По умолчанию уровень изоляции InnoDB – REPEATABLE READ, который достигается за счет многоверсионности: все SELECT внутри транзакции видят состояние данных на начало транзакции, без блокировок. Таким образом, чтения не конфликтуют с записывающими транзакциями: если данные изменяются параллельно, читающая транзакция получает прежнее значение из undo-лога. Однако при выполнении операций модификации (INSERT/UPDATE/DELETE) InnoDB устанавливает эксклюзивные блокировки на затронутые записи. Для предотвращения <<фантомных>> вставок в уровне SERIALIZABLE и в повторяемом чтении InnoDB применяет \textit{gap locks} – блокировки не только на сами существующие строки, но и на диапазоны значений, отсутствующие в индексе. Это гарантирует, что другой транзакции не удастся незаметно <<вставить фантом>> в результат выборки первой транзакции, но такие блокировки диапазонов могут снижать параллелизм. В целом, MySQL стремится комбинировать преимущества версионности и традиционных блокировок: большинство чтений не блокируют изменения, а изменения локализованы блокировками на уровне строк. Мониторинг блокировок InnoDB возможен с помощью команды \texttt{SHOW ENGINE INNODB STATUS}, которая выводит сведения о текущих блокировках и последней обнаруженной взаимоблокировке, либо через таблицы \texttt{INFORMATION\_SCHEMA.INNODB\_LOCKS} / \texttt{INNODB\_LOCK\_WAITS}. Администратор MySQL может задать параметр \texttt{innodb\_lock\_wait\_timeout} для автоматического прерывания транзакций, ожидающих блокировку дольше заданного времени (по умолчанию 50 секунд).
 \end{itemize}

\paragraph{3. Взаимодействие с журналом транзакций и буфером} ~\\

 Система управления транзакциями должна не только предотвращать конфликтующий доступ через блокировки, но и гарантировать надежное сохранение данных (принципы долговечности и атомарности транзакций). Поэтому механизм блокировок тесно увязан с журнальным файлом (лог-файлом) транзакций (\textit{Write-Ahead Log}, WAL) и подсистемой кеширования страниц (буферный пул). 
 
 Когда транзакция начинает выполнять операции, менеджер блокировок обеспечивает \textit{протокол двух фаз}: сначала транзакция захватывает все необходимые блокировки (ростущая фаза), затем после точки фиксации (\texttt{COMMIT}) – освобождает их (фаза сброса). Важно, что блокировки удерживаются как минимум до тех пор, пока транзакция не решит зафиксировать изменения. Это соответствует строгому 2PL: все блокировки держатся вплоть до завершения транзакции (фиксации или отката) \autocite{WashCoursesLec5}. Такое правило гарантирует, что ни одна другая транзакция не прочитает <<неразрешённые>> данные, которые потом могут быть отменены, и что при откате все изменения откатываются без влияния на других. 
 
 Перед фиксацией изменений нужно обеспечить долговечность (Durability) – т.е. записать все сделанные изменения на стабильное хранилище. Однако напрямую сбрасывать на диск сами изменённые страницы при каждом \texttt{COMMIT} было бы неэффективно. Современные СУБД используют протокол <<Запись-журнала-до>> (WAL): перед фиксацией достаточно записать в журнал транзакций все записи о сделанных изменениях (redo-записи и при необходимости undo-информацию), и дождаться их физического сброса на диск. Только после этого транзакция считается зафиксированной, и можно освободить её блокировки. Таким образом достигается атомарность: если система сбойнет сразу после фиксации, то благодаря журналу все изменения транзакции смогут быть восстановлены при перезапуске; если же сбойнет до фиксации, то незавершённые изменения не увидят другие транзакции (блокировки их удерживали) и будут отменены на основе undo-логов при восстановлении. ~\\
 
 Рассмотрим упрощённо шаги изменения данных в СУБД и роль блокировок, журнала и буфера. Пусть пользователь выполняет команду \texttt{UPDATE} для некоторой строки. Серверные процессы выполняют следующие действия \autocite{oracleessentialsc7}: 
 \begin{enumerate}
    \item Получают блокировку на соответствующие данные – например, эксклюзивную блокировку на изменяемую строку или страницу, чтобы другие транзакции не могли её менять или читать (в режиме более высокого изолирования). 
    \item Считывают нужный блок данных с диска в буферную память (если он ещё не в буфере) и делают копию старого состояния изменяемой строки в область отката (undo) для обеспечения возможного отката и консистентных чтений. 
    \item В буферном блоке применяют изменение – т.е. обновляют значение. Эта операция производится в памяти и сопровождается пометкой страницы как <<грязной>> (dirty) в буферном пуле. Параллельно, система формирует описание изменений для журнала: фиксирует, что в такой-то таблице, странице, смещении было старое значение X, стало новое Y (redo-запись), и пишет эту информацию в \textit{лог-буфер} (область памяти для журналируемых записей). 
    \item В момент, когда пользователь подтверждает транзакцию (\texttt{COMMIT}), СУБД сначала присваивает транзакции новый системный номер изменения (SCN/LSN) и заносит в журнал соответствующую запись \texttt{COMMIT}. Затем выполняется операция фиксации: процесс записи журнала (например, фоновой поток Log Writer в Oracle, или аналогичный механизм в других СУБД) сбрасывает из лог-буфера на диск все записанные за транзакцию журнальные записи, включая запись о самом коммите. Шаг является ключевым: только после успешной фиксации журнала на диске транзакция считается завершённой.
    \item После этого менеджер блокировок освобождает все блокировки, принадлежащие данной транзакции, и другие сессии, ожидавшие этих ресурсов, могут продолжить работу. Данные, изменённые транзакцией, пока могут оставаться только в буферном пуле (на диск они, возможно, ещё не записаны) – благодаря протоколу WAL это не опасно, поскольку при сбое уже есть журнал, с которого изменения можно воспроизвести на диск. Запись изменённых страниц на постоянное хранение может быть отложена (подход \textit{no-force}: страницы не обязательно сбрасывать прямо при коммите, это делает фоновый процесс периодически или при вытеснении страницы из буфера). Такая отложенная запись увеличивает общую пропускную способность, позволяя группировать операции ввода-вывода. 
 \end{enumerate}

 Механизм блокировок играет роль и при восстановлении после сбоев. В классических алгоритмах восстановления (как ARIES) во время рестарта системы выполняется повторное проигрывание журнала и откат незавершённых транзакций. Для этого система может временно устанавливать необходимые блокировки на изменяемые данные, чтобы новые транзакции не вмешивались в <<чистку>> хвостов незавершённых транзакций. После завершения восстановления эти временные блокировки снимаются. 

 Важно различать \textit{логические блокировки} транзакций, о которых шла речь выше, и более низкоуровневые механизмы синхронизации в буферном менеджере – так называемые \textit{latches}, мьютексы, спинлоки. Латчи защищают целостность внутренних структур (например, никто не должен читать полусформированный индексный узел в памяти, пока другой поток его изменяет) и обычно удерживаются кратковременно (на время нескольких операций с памятью). Они не связаны напрямую с транзакционной изоляцией и не удерживаются до конца транзакции – напротив, освобождение лока происходит сразу по завершении критической секции кода. Пользователь их не наблюдает, но они влияют на реализацию: например, при обновлении страницы в буфере сначала ставится эксклюзивная \textit{ляч-блокировка} на буфер (чтобы синхронно применить изменение), а уже после этого фиксируется долгосрочная транзакционная блокировка. Таким образом, латы обеспечивают корректность параллельной работы потоков в памяти, а транзакционные блокировки – корректность на уровне логики concurrent-доступа к данным. 

 Резюмируя, взаимодействие блокировок, журнала и буфера выражается в следующих принципах:
 \begin{itemize}
    \item Блокировки предотвращают преждевременный конкурентный доступ к изменяемым данным до завершения транзакции, тем самым обеспечивая изоляцию и упорядоченность изменений.
    \item Журнал фиксирует изменения до их физического применения на диске (WAL), что позволяет освобождать блокировки сразу после коммита, не дожидаясь записи данных на диск, и всё же гарантировать восстановление данных после сбоя.
    \item Буферный кеш позволяет накопить изменения в памяти и применить их к страницам батчами; блокировки и журнал вместе гарантируют, что такие отложенные записи не нарушат согласованность данных: либо транзакция с их изменениями не считается committed (и тогда её данные никто не прочтет, а при сбое они откатятся), либо, если считана committed, то журнал на диске позволяет довести изменения до диска даже постфактум.
 \end{itemize}

\paragraph{4. Таблицы блокировок и внутренние представления} ~\\

 Внутри СУБД все сведения о выданных и ожидающих блокировках хранятся в специализированной структуре данных – \textit{таблице блокировок} (lock table) в памяти. Менеджер блокировок ведет эту таблицу, регистрируя каждую запрошенную или удерживаемую блокировку. В типичной реализации таблица блокировок представляет собой хеш-таблицу, где ключом является идентификатор ресурса (например, <<страница 123 файла таблицы T>> или <<строка со значением ключа K в индексе>>). Значение по каждому ключу – запись, содержащая информацию о текущем состоянии блокировки данного ресурса: какой режим блокировки установлен (или запрашивается), сколькими транзакциями и какими именно он удерживается, а также очередь ожидания (список транзакций, которые заблокированы в ожидании этого ресурса). 
 
 Например, если транзакция $T_1$ удерживает эксклюзивную блокировку на некоторой записи, а транзакция $T_2$ запросила эксклюзивную блокировку на тот же ресурс, то в таблице будет одна запись ресурса с пометкой: блокировка в режиме X выдана для $T_1$, а $T_2$ стоит в очереди ожидания. Менеджер блокировок, получая новые запросы, проверяет эту таблицу: совместим ли требуемый режим с уже выданными блокировками. Если да – обновляет запись (добавляет транзакцию в список держателей и, возможно, изменяет совокупный режим – например, помечая, что ресурс теперь имеет несколько shared-блокировок). Если нет – помещает запрос в очередь ожидателей и приостанавливает транзакцию. Такая таблица блокировок является \textit{общей} для всей СУБД (или экземпляра/узла) – глобальная структура в общей памяти, доступная всем процессам. Поэтому к ней предъявляются высокие требования по эффективности: поиск и обновление должны быть быстрыми. Используется хеширование по идентификатору ресурса для $O(1)$ доступа \autocite{DMSSMthed}, а для синхронизации доступа разных потоков к таблице применяются легковесные лочи (напрямую не видимые приложению). 
 
 В записях таблицы часто кэшируется дополнительная информация для ускорения работы. Например, менеджер может поддерживать при каждой транзакции список всех ресурсов, которые она заблокировала, чтобы при завершении быстро их освободить, не сканируя всю таблицу \autocite{Silberschatz}. С точки зрения пользователя, внутренняя таблица блокировок чаще всего не видна напрямую, однако СУБД обычно предоставляют специальные представления или утилиты, чтобы можно было посмотреть, какие блокировки сейчас удерживаются и кем. В PostgreSQL, как упоминалось, существует представление \texttt{pg\_locks}, в котором каждая строка отображает один объект блокировки (таблица, страница, строка и т.д.), запрошенный режим и ID процесса/транзакции. Объект, не имеющий активных блокировок, просто не появляется в этом списке.
 
 Поля представления показывают тип объекта (\texttt{locktype}: например, \texttt{relation}, \texttt{tuple}, \texttt{transactionid} и др.), идентификаторы объекта (OID базы, relation и т.п.), режим блокировки (\texttt{mode}, например \texttt{RowExclusiveLock}) и флаг, выдана ли она (\texttt{granted} = true/false). Аналогично, в Oracle есть представление \texttt{V\$LOCK}, отображающее все текущие блокировки и заявки: для каждой блокировки указывается сессия (SID), тип (например, TM, TX), режим удержания (LMODE) и запрошенный режим (REQUEST) в числовом коде, время удержания и признак блокировки других сессий. В Microsoft SQL Server доступна DMV \texttt{sys.dm\_tran\_locks}, где каждая строка – отдельная блокировка или ожидание: она включает тип ресурса (RID = запись, KEY = ключ индекса, PAGE, OBJECT = таблица и пр.), запрошенный режим (S, X, U, IS, IX...), статус (granted или waiting) и связанные идентификаторы объекта и транзакции. Внутренние <<таблицы блокировок>> нередко имеют ограничения на размер, чтобы предотвратить бесконечный рост расхода памяти на информацию о блокировках. Например, в PostgreSQL параметр \texttt{max\_locks\_per\_transaction} определяет, сколько различных объектов в среднем может блокировать одна транзакция; объём памяти, выделяемый для таблицы блокировок, рассчитывается на основе этого значения (по умолчанию 64 объекта) и количества транзакций в системе. Хотя число заблокированных строк не ограничено напрямую (поскольку все строки одной таблицы считаются одним объектом на уровне блокировки таблицы), при работе с очень большим числом разных таблиц или индексов в одной транзакции администратору, возможно, придется увеличить этот параметр, иначе при превышении лимита новых блокировок транзакции будут получать ошибки. В других СУБД (например, Oracle) статических ограничений на количество блокировок обычно нет – используется динамическое управление памятью, хотя существуют параметры, влияющие на размер памяти для трансакционной обработки в целом. 
 
 \subparagraph{Внутреннее представление режимов блокировок} ~\\

 Разные СУБД поддерживают наборы режимов блокировок, более богатые, чем простая схема Shared/Exclusive. Например, почти все промышленный СУБД реализуют \textit{многоуровневые блокировки} (multi-granularity locking) с \textit{намерениями} блокировок. В таблице блокировок могут храниться режимы: \textbf{IS} (Intention Shared) – транзакция намерена ставить shared-блокировки на дочерние объекты; \textbf{IX} (Intention Exclusive) – намерена ставить exclusive-блокировки на дочерние; \textbf{SIX} (Shared with Intent Exclusive) – комбинированный режим, означающий, что объект удерживается в shared-режиме, но у транзакции есть эксклюзивные блокировки на часть нижележащих ресурсов. Эти режимы нужны, чтобы при блокировке крупного объекта (например, всей таблицы) быстро определить, имеются ли внутри уже локальные блокировки. СУБД проверяет: если кто-то держит, скажем, IX на таблице, то другому процессу нельзя сразу поставить на эту таблицу эксклюзивную блокировку X (ему придётся ждать), не глядя на все отдельные строки \autocite{sqlhack1}. 
 
 Намерения позволяют избежать пролистывания тысяч записей о строчных блокировках каждый раз, когда кто-то пытается заблокировать всю таблицу – достаточно видеть флаг в записи таблицы. Тончайшие детали реализации (например, наличие специального Update-режима U в SQL Server для предотвращения конверсионных deadlock’ов, отдельные блокировки для индексных кортежей, лочки-метки для управления ростом таблицы и др.) – это всё внутренние особенности. Но они отражаются и наружу через представления: так, в \texttt{pg\_locks} можно увидеть типы \texttt{tuple}, \texttt{page}, \texttt{extend} (блокировка на право расширения таблицы), \texttt{predicate} (признаки блокировок в SSI), \texttt{transactionid} (блокировка на идентификатор транзакции при ожидании ее завершения) и даже \texttt{advisory} (прикладные блокировки по произвольным ключам). Эти элементы демонстрируют богатство типов блокируемых ресурсов и режимов в современных СУБД.

\paragraph{5. Управление конфликтами блокировок} ~\\

 Конфликт блокировок возникает, когда одна транзакция запрашивает ресурс в режиме, несовместимом с режимом, уже удерживаемым другой транзакцией. Например, транзакция $T_1$ удерживает exclusive-блокировку записи, а транзакция $T_2$ хочет её прочитать (т.е. запросить shared-блокировку) – это конфликт, потому что S и X несовместимы; либо более тривиальный случай: две транзакции обе хотят X на одну и ту же строку. В таких ситуациях СУБД должна грамотно управлять конфликтом: решить, будет ли одна транзакция ждать, будет ли какая-то из них прервана, и как избежать взаимных <<вечных>> ожиданий (deadlock). Основные стратегии разрешения конфликтов блокировок:
 \begin{itemize}
    \item \textbf{Ожидание (блокировка до освобождения)} ~\\
    Базовый подход – транзакция, не получившая нужную блокировку, переходит в состояние ожидания, пока ресурс не освободится. Например, если $T_1$ держит X-блокировку, а $T_2$ запрашивает X на тот же объект, то $T_2$ будет спать, пока $T_1$ не завершится (или не откатится). Такой подход гарантирует, что транзакции просто выстроятся в очередь и рано или поздно все смогут выполнить свои операции. Однако простой механизм ожидания чреват взаимоблокировками: ситуация, когда $T_1$ ждет ресурс у $T_2$, а $T_2$ – ресурс у $T_1$ (или более сложный цикл из нескольких транзакций). Ни одна из них не завершится, они будут ждать бесконечно, если система ничего не предпримет. Поэтому одних ожиданий недостаточно – СУБД должна либо предотвращать появление deadlock-ситуаций, либо уметь их обнаруживать и разруливать 
    \item \textbf{Предотвращение deadlock (Deadlock Prevention)} ~\\
    В этой стратегии система навязывает правила, гарантирующие, что цикл ожидания не сможет образоваться. Классические алгоритмы предотвращения взаимоблокировок используют метки времени транзакций (timestamps), чтобы ввести строгий порядок. Два известных протокола – \textit{Wait-Die} и \textit{Wound-Wait}. В обоих алгоритмах каждой транзакции присваивается временная метка начала (TS). Когда одна транзакция хочет ресурс, занятый другой, сравниваются их метки: 
    \begin{itemize}
        \item \textbf{Wait-Die (<<ждать или умереть>>)} - если запрашивающая ресурс, началась раньше (её временная метка TS меньше), чем транзакция, удерживающая данный ресурс, то она \textit{ждет} освобождения ресурса; если же транзакция началась позже (её TS больше), чем у удерживающей ресурс транзакции, то она не ждет, а немедленно откатывается (прерывается). Например, $T_i$ (со старшей меткой) хочет блокировку, которую держит $T_j$ (моложе) – $T_i$ будет ждать; если же младшая транзакция хочет ресурс старшей, то младшая сразу откатывается (и затем перезапускается с тем же таймстампом, чтобы сохранить относительный порядок)
        \item \textbf{Wound-Wait (<<ранить или ждать>>)} – противоположная политика: если транзакция, запрашивающая ресурс, началась раньше (имеет меньшую временную метку), чем транзакция, удерживающая ресурс, то она <<ранят>> младшую транзакцию — принудительно её откатывает (освобождая ресурс); если же запрашивающая транзакция младше удерживающей, она просто \textit{ждёт}. Иными словами, более старая транзакция всегда имеет приоритет: если ей нужен занятый ресурс, который удерживает более молодая транзакция, последняя откатывается; если же ресурс занят более старшей транзакцией, младшая просто ожидает. Откатанные транзакции автоматически перезапускаются (с теми же временными метками, чтобы сохранить порядок). Оба протокола предотвращают взаимные блокировки: в Wait-Die младшие транзакции могут несколько раз откатываться, пока не окажутся в правильной очереди; в Wound-Wait старшая транзакция никогда не ждёт младшую — она либо немедленно получает доступ к ресурсу, либо младшая ждёт освобождения.
        \item Существуют и другие стратегии предотвращения, не требующие меток времени: например, \textbf{<<No-Wait>>} – транзакция вообще не ждет, если ресурс занят, а сразу откатывается (такая политика используется, например, для некоторых DDL-операций: если таблица занята, DDL не будет ждать, а вернёт ошибку сразу). Или \textbf{<<Cautious Waiting>>} – транзакция ждет ресурс только если владелец этого ресурса не находится в состоянии ожидания другого ресурса (т.е. владелец <<активно работает>>, тогда ждать безопасно, иначе потенциально есть цепочка ожиданий и лучше откатиться). Эти подходы тоже предотвращают взаимные ожидания, но могут быть слишком консервативны, приводя к лишним откатам. 
    \end{itemize}
    \item \textbf{Обнаружение deadlock (Deadlock Detection)} ~\\
    Эта стратегия допускает, что взаимоблокировки могут происходить, но система умеет их распознать и ликвидировать. Практически все современные СУБД реализуют детекцию deadlock’ов, поскольку полностью избежать их в гибкой конкурентной среде сложно. Детектор отслеживает граф ожидания транзакций (wait-for graph): узлы – транзакции, ребро из $T_i$ в $T_j$ означает, что $T_i$ ждет ресурс, удерживаемый $T_j$. Если в таком графе появляется цикл, значит имеется deadlock. СУБД периодически (или при определенных событиях) анализирует зависимости. Например, в PostgreSQL настроен параметр \texttt{deadlock\_timeout} (по умолчанию 1 с) – если транзакция ждет блокировку дольше этого времени, сервер выполняет проверку на наличие взаимоблокировки \autocite{PostgreSQLdocc19}. 
    
    Проверка – достаточно затратная операция, поэтому её делают не при каждом ожидании, а только по истечении таймаута в надежде, что конфликты обычно рассосутся сами \autocite{PostgreSQLdocc19}. Если обнаружен цикл, система выберет <<жертву>> – одну из транзакций в цикле – и принудительно откатит её, разрубая взаимоблокировку. Как правило, выбирают транзакцию, которая принесёт наименьшие потери: например, в SQL Server детектор просчитывает <<стоимость>> отката (по количеству изменённых строк, журнальных записей) и жертвой делает самую <<лёгкую>> транзакцию, возвращая ей ошибку <<deadlock victim>>. В PostgreSQL по умолчанию жертвой станет та транзакция, которая первым заметила deadlock (или случайная из цикла) – она получит ошибку \texttt{ERROR: deadlock detected}, а ее изменения откатятся. Oracle аналогично при обнаружении цикла сразу откатывает одну из транзакций (с меньшим \texttt{SID}, по документам) с ошибкой ORA-00060 (deadlock detected). MySQL InnoDB также проводит мгновенную детекцию: когда транзакция вынуждена ждать, движок просматривает граф зависимостей; если обнаруживается цикл, одна из участвующих транзакций откатывается (ей возвращается ошибка <<Deadlock found>>), а другая получает ресурс. Во всех случаях освобождение блокировок жертвой позволяет остальным продолжить работу. \item \textbf{Таймауты ожидания.} Дополнительный механизм управления конфликтами – ограничение времени ожидания блокировки. Он не гарантирует предотвращения deadlock (поскольку таймаут прерывает даже <<честное>> ожидание, не обязательно взаимное), но может служить страховкой. Например, если транзакция ждет более $N$ секунд, можно прервать её ожидание с ошибкой. В Oracle для DML обычно не применяется глобальный таймаут, но в команде \texttt{SELECT FOR UPDATE} можно указать \texttt{NOWAIT} (не ждать вообще) или \texttt{WAIT 5} (ждать максимум 5 секунд). В SQL Server есть командный \texttt{SET LOCK\_TIMEOUT} для задания таймаута (по умолчанию бесконечно, т.е. ждать без срока). В MySQL параметр \texttt{innodb\_lock\_wait\_timeout} задаёт время в секундах (по умолчанию 50 с) – если за это время блокировка не получена, транзакция откатывается с ошибкой. В PostgreSQL можно установить \texttt{lock\_timeout} в миллисекундах на уровне сеанса или конфигурации – по истечении этого времени любое новое ожидание блокировки будет немедленно прерывать операцию с ошибкой. Таймауты полезны для повышения отзывчивости приложений: вместо того чтобы подвисать <<вечно>>, запрос через заданное время вернёт ошибку, и приложение сможет обработать ситуацию (например, повторить транзакцию). 
    \item \textbf{Управление очередью и устранение голодания} ~\\
    Даже при отсутствии deadlock возможна проблема \textit{starvation} (голодания), когда определенная транзакция очень долго не получает ресурс, потому что её постоянно <<обходят>> другие. Например, если политика выбора жертвы при deadlock всегда откатывает самую молодую транзакцию, то при постоянном потоке новых транзакций какая-то из них может постоянно откатываться и никогда не завершиться. СУБД стараются этого избегать: обычно заявки на блокировку выстраиваются в очередь FIFO (порядок поступления) – тогда даже если появляются новые конкуренты, старый ждун получит ресурс первым, как только он освободится. В некоторых системах реализованы механизмы повышения приоритета ожидающей транзакции, если она ждёт уж слишком долго. В SQL Server, например, существует флаг \texttt{READ\_COMMITTED\_LOCK} для обеспечения более честного планированияReaders, а также продвинутый функционал \textit{Resource Governor} для управления ресурсными очередями, но это выходит за рамки блокировок как таковых. В большинстве случаев правильная очередь ожидания и алгоритмы отказа от циклов предотвращают голодание эффективно, и все транзакции рано или поздно либо получают свои ресурсы, либо откатываются (с последующим ретраем, если это предусмотрено приложением).
 \end{itemize} 
 Заметим, что конкретная СУБД может комбинировать эти подходы. Например, основная стратегия – ожидание + обнаружение deadlock, но при этом администратор может задать таймаут, после которого ожидание прервётся. Или, скажем, в Oracle по умолчанию нет таймаута (транзакция будет ждать ресурс, пока не случится deadlock или не пройдет бесконечно много времени), а в MySQL таймаут стоит всегда. Алгоритмы предотвращения (wait-die, wound-wait) редко используются в чистом виде в массовых СУБД, поскольку они приводят к частым откатам в нагруженных системах; однако идеи приоритетов по возрасту могут использоваться при выборе жертвы в детекторе deadlock. В целом, управление конфликтами блокировок стремится минимизировать откаты (которые затратны) и при этом не допустить ситуаций, когда транзакции подвисают навечно друг из-за друга.

\paragraph{6. Администрирование и отладка} ~\\

 При разработке и сопровождении БД зачастую требуется выяснить, какие блокировки возникают, кто кого блокирует, и почему, а также уметь реагировать на конфликтные ситуации. СУБД предоставляют различные средства для мониторинга и управления блокировками. Рассмотрим основные из них: 
 \begin{itemize}
    \item \textbf{Мониторинг текущих блокировок} ~\\
    Администратор базы данных может в любой момент посмотреть, какие блокировки удерживаются и ожидаются. Как отмечалось, существуют системные представления (\texttt{pg\_locks}, \texttt{V\textdollar LOCK}, \texttt{sys.dm\_tran\_locks}, \texttt{INFORMATION\_SCHEMA.INNODB\_LOCKS} и др.), которые показывают снимок состояния lock-менеджера. Обычно просматривая их в сочетании с представлениями активных сессий (такими как \texttt{pg\_stat\_activity} в PostgreSQL, \texttt{V\textdollar SESSION} в Oracle, \texttt{sys.dm\_exec\_sessions} в SQL Server), можно установить: какая транзакция или запрос сейчас ждет блокировку, и кто является владельцем ресурса. Например, в PostgreSQL популярна диагностическая команда:
    \begin{lstlisting}[language=SQL]
        SELECT blocked.pid AS blocked_pid, blocked.query AS blocked_query,
        blocking.pid AS blocking_pid, blocking.query AS blocking_query
        FROM pg_locks blocked
        JOIN pg_stat_activity blocking ON blocking.pid = blocked.pid
        JOIN pg_locks blocking_lock ON blocking_lock.locktype = blocked.locktype
        AND blocking_lock.database = blocked.database
        AND blocking_lock.relation = blocked.relation
        JOIN pg_stat_activity blocked ON blocked.pid = blocked_lock.pid
        WHERE NOT blocked.granted;
    \end{lstlisting}

    (здесь соединяются \texttt{pg\_locks} сама с собой и с \texttt{pg\_stat\_activity}, чтобы найти пары <<кто блокируется / кто блокирует>>). Аналогичные запросы или утилиты существуют для других СУБД: в Oracle можно связать \texttt{V\textdollar LOCK} (по идентификаторам SID) с \texttt{V\textdollar SESSION} для получения имен пользователей и выполняемых запросов, в SQL Server – использовать \texttt{sys.dm\_exec\_requests} (поля \texttt{blocking\_session\_id} показывают, кто блокирует данный SPID) или воспользоваться хранимой процедурой \texttt{sp\_who2}. В MySQL вывод \texttt{SHOW ENGINE INNODB STATUS} в секции \textit{LATEST DETECTED DEADLOCK} и \textit{TRANSACTIONS} показывает, какие транзакции удерживают блокировки и какие ждут. Таким образом, администратор может в режиме реального времени выявить <<узкие места>> – например, видны долгоживущие транзакции, держащие блокировки, или конкретные строки таблицы, вокруг которых идет конкуренция
    
    \item \textbf{Диагностика зависаний и взаимоблокировок} ~\\
    Когда приложение <<висит>>, подозрение часто падает на блокировки. Инструменты мониторинга, описанные выше, помогут увидеть, если ли блокирующие транзакции. Если обнаружена взаимоблокировка (deadlock), СУБД обычно самостоятельно её ликвидирует, но важно понять причину. В PostgreSQL при обнаружении deadlock-а сервер не только откатывает одну из транзакций, но и пишет в журнал подробности: например, логи содержат сообщение \texttt{ERROR: deadlock detected} с описанием, какие процессы и из-за каких ресурсов образовали цикл ожидания, и какие SQL-запросы у них были активны. Аналогично, SQL Server при трассировке (флаг \texttt{1204} или Extended Events) может выдать <<граф взаимоблокировки>> – XML или текст с указанием участников, ресурсов и типов блокировок, повлекших deadlock. Oracle записывает в трассировочный файл отчет о взаимоблокировке (включая последние запросы и текст удерживаемых блокировок). Администратору следует проанализировать эти данные: часто оказывается, что два конкретных SQL запроса конфликтуют (например, апдейты двух таблиц в разном порядке). Решением может быть изменение приложения – например, всегда брать блокировки в одном и том же порядке, или добавить индексы, чтобы уменьшить область блокирования, или перейти на более мягкий уровень изоляции, если допустимо
    \item \textbf{Логирование ожиданий блокировок} ~\\
    Для отладки <<тяжелых>> блокировочных ситуаций полезно включить специальное логирование. В PostgreSQL параметр \texttt{log\_lock\_waits = on} заставляет сервер писать в лог предупреждения, если ожидание блокировки длится более \texttt{deadlock\_timeout} (обычно 1 с) \autocite{PostgreSQLdocc19}. Тогда даже если deadlock не произошёл (то есть блокировка в итоге получена), в логе останется запись о длительной блокировке – с указанием транзакции и типа блокировки. Это позволяет в постаналитике понять, что, к примеру, в 14:35 транзакция A ждала 5 секунд, пока транзакция B завершится. В Oracle есть схожий механизм: событие \texttt{LOCK\_TIMEOUT} можно отслеживать через System Event 60 (enqueue waits) в AWR-отчётах, а также Oracle генерирует предупреждения, если ожидание блокировки превышает определённый порог (для этого на уровне приложения иногда используют параметр \texttt{RESOURCE\_MANAGER} или просто периодический мониторинг \texttt{V\textdollar SESSION\_WAIT}). В SQL Server можно настроить Extended Event \texttt{lock\_timeout} или \texttt{blocked\_process\_report} (последнее – отчёт о процессе, заблокированном дольше N секунд, нужно включить \texttt{TRACE FLAG 1222} и \texttt{blocked process threshold}). Эти средства позволяют собрать статистику по блокировкам и понять, есть ли в системе тенденция к долгим блокированиям 
    \item \textbf{Управление (разблокирование) вручную} ~\\
    В случае, когда обнаружена проблемная ситуация – например, одна из сессий <<повисла>>, удерживая важные ресурсы – администратор может принять меры. Если приложение допускает, лучшим решением будет корректно завершить транзакцию с той стороны (например, послать отмену запроса). Но если это невозможно, СУБД позволяет принудительно снять блокировки, убив сессию. В PostgreSQL для этого служит функция \texttt{pg\_terminate\_backend (pid)} – она завершает серверный процесс указанного PID, тем самым вся транзакция откатывается, а блокировки освобождаются. В Oracle – команда \texttt{ALTER SYSTEM KILL SESSION 'SID,serial'} (или в Enterprise Manager есть кнопка <<Kill Session>>). В SQL Server – командa \texttt{KILL <SPID>}. В MySQL – \texttt{KILL <thread\_id>}. Эти команды надо применять осторожно: <<убитая>> транзакция откатится (что может быть долгим процессом, если она сделала много изменений). Кроме того, в некоторых СУБД (Oracle) после \texttt{KILL SESSION} транзакция еще некоторое время помечена как <<marked for kill>> и освобождает ресурсы не мгновенно. Тем не менее, в аварийных ситуациях это единственный способ разрубить затянувшуюся блокировку. Также администратор может временно запретить новым транзакциям доступ к проблемным объектам, переведя их в режим обслуживания, однако это скорее организационная мера
    \item \textbf{Настройка параметров блокировок} ~\\
    СУБД имеют ряд конфигурационных параметров, влияющих на поведение блокировок. Мы уже упоминали \texttt{deadlock\_timeout}, \texttt{lock\_timeout}, \texttt{innodb\_lock\_wait\_timeout} и др. Кроме них, есть параметры, определяющие, сколько ресурсов может быть заблокировано (например, \texttt{max\_locks\_per\_transaction} в Postgres) или будут ли использоваться блокировки для чтений (в SQL Server параметр базы \texttt{READ\_COMMITTED\_SNAPSHOT} включает версионность вместо shared-lock для уровня Read Committed). Администратор должен знать эти настройки и оптимально их конфигурировать под свое приложение. Например, если приложение часто страдает от взаимоблокировок, имеет смысл снизить \texttt{deadlock\_timeout} (чтобы быстрее обнаруживать циклы) или переключиться на снапшот-изоляцию, если это приемлемо. Если наблюдаются длительные блокировки, полезно временно включить \texttt{log\_lock\_waits} и проанализировать лог. В случае, когда транзакции блокируют слишком много объектов и упираются в ограничение по памяти, можно увеличить соответствующий параметр (в Oracle автоматически наращивается \texttt{ENQUEUE\_RESOURCES}, в Postgres – поменять \texttt{max\_locks\_per\_transaction} и перезапустить сервер). Хорошая настройка и мониторинг способны предотвратить многие проблемы с блокировками ещё до того, как они начнут влиять на пользователей.
 \end{itemize} 

 В итоге, администрирование блокировок сводится к трём основным задачам: 
 \begin{enumerate}
    \item Наблюдение – своевременно видеть ситуацию (кто кого ждёт, есть ли deadlock)
    \item Анализ и настройка – понимать, почему возникают проблемы (долгое ожидание, частые конфликтные запросы) и либо изменить код запросов/транзакций, либо настроить СУБД (уровень изоляции, таймауты, индексы) для смягчения конфликтов
    \item Реагирование – уметь безопасно завершить проблемные процессы, если они уже повисли. Благо современные СУБД оснащены всем необходимым для этих целей инструментарием
 \end{enumerate}

\paragraph{7. Подходы к оптимизации управления блокировками} ~\\

 Эффективный менеджер блокировок должен обеспечивать баланс между строгой изоляцией и максимальной производительностью. Существует несколько подходов и приемов, позволяющих ускорить работу системы блокировок и снизить накладные расходы: 
 \begin{itemize}
    \item \textbf{Гранулярность блокировок и эскалация} ~\\
    Одно из решений – на каком уровне блокировать данные (строка, страница, таблица, вся база). Мелкая гранула (строки) повышает параллелизм – разные транзакции могут работать с разными строками одной таблицы без конфликтов, – но требует больше памяти и времени на отслеживание множества блокировок. Крупная гранула (вся таблица) сокращает число блокировок, но повышает вероятность ложных конфликтов. СУБД обычно позволяют динамически переключаться: например, SQL Server, IBM DB2 поддерживают \textit{эскалацию блокировок}, когда система сама решает повысить уровень. Если транзакция заблокировала сотни или тысячи строк одной таблицы, менеджер может автоматом конвертировать это в блокировку всей таблицы, вместо того чтобы хранить огромный список строковых блокировок \autocite{oracleessentialsc7}. Это уменьшает нагрузку на lock table и экономит память. Однако эскалация может и снизить параллелизм (залочив даже те строки, к которым транзакция не обращалась). Поэтому механизмы эскалации обычно настроены консервативно: например, SQL Server попытается эскалировать блокировки, когда их более 5000 на объект, и то не всегда – есть ряд условий и можно отключить эскалацию для конкретных таблиц. Oracle, наоборот, принципиально не делает эскалацию – он рассчитан на то, что сможет держать миллионы мелких блокировок (на каждую строку) без ощутимых издержек, за счет хранения их в блоках данных и эффективного управления транзакционными слотами \autocite{oracleessentialsc7} 
    \item \textbf{Иерархические блокировки, намерения} ~\\
    Механизм \textit{иерархических (многоуровневых) блокировок} позволяет сочетать разную гранулярность. Например, транзакция может поставить блокировки на несколько отдельных страниц таблицы, а другая транзакция – сразу на всю таблицу. Чтобы они корректно сосуществовали, используются \textbf{намерения блокировок}: когда транзакция блокирует мелкий ресурс, она ставит на вышележащий объект пометку-<<намерение>> (IS или IX), сигнализируя потенциальным конкурентам. Благодаря этому, если другая транзакция захочет заблокировать весь объект целиком, она увидит намерения и поймёт, что внутри объект уже частично занят – значит, придётся ждать или отказаться. Намерения существенно ускоряют такие проверки \autocite{sqlhack1}. Кроме того, они помогают при эскалации: прежде чем эскалировать, система проверит, нет ли конфликтующих намерений от других транзакций. Иерархическое управление блокировками – оптимизация, позволяющая и хранить меньше блокировок (если нужно, укрупнять их), и в то же время не лишать систему гибкости в плане параллелизма. Современные СУБД поддерживают намерения (IS/IX/SIX, см. выше), и программисту обычно не нужно о них думать – они работают автоматически под капотом, улучшая производительность блокировок
    \item \textbf{Разделение менеджера блокировок (partitioning, sharding)} ~\\
    В высоконагруженных системах узким местом может стать сама таблица блокировок: если сотни потоков одновременно ставят блокировки, они могут конкурировать за доступ к общей структуре. Разработчики СУБД используют различные приёмы для масштабирования: разделение таблицы блокировок на сегменты (по хэшу ресурса) с отдельными локальными latch’ами на каждый сегмент, чтобы параллельные запросы к разным сегментам не блокировали друг друга. Например, в Oracle реализация \textit{Enqueue Services} использует несколько хеш-списков для разных типов энкю и сложные алгоритмы уменьшения конкуренции на <<горячих>> ресурсах. В SQL Server начиная с определенной версии тоже были изменения для увеличения конкуренции – ввели несколько списков ожидания и улучшили алгоритм эскалации, чтобы не лочить всю таблицу каталогов блокировок. Конкретные техники – внутренние, но суть в том, что \textbf{масштабирование lock-manager-а} достигается минимизацией точек сериализации. В однопоточном СУБД это не проблема, но на десятках ядер и тысячах коннекшенов оптимизированный менеджер блокировок – необходимое условие
    \item \textbf{Сокращение длительности блокировок} ~\\
    Чем меньше времени транзакции удерживают блокировки, тем выше общая пропускная способность. Поэтому оптимизация управления блокировками включает и оптимизацию транзакций: рекомендуется держать транзакции как можно короче – чтобы они не <<захватывали>> ресурсы надолго. Разработчикам советуют не проводить длительных вычислений внутри транзакции после взятия блокировок, не ждать ввода пользователя и т.п. Кроме дисциплины программирования, СУБД сами идут навстречу: более слабые уровни изоляции (Read Committed vs Repeatable Read vs Serializable) позволяют раньше освобождать некоторые блокировки. Например, в режиме Read Committed многие СУБД освобождают shared-блокировки сразу после чтения данных (не дожидаясь конца транзакции), что увеличивает параллелизм – в то время как в Repeatable Read те же блокировки держались бы до коммита. Это компромисс в пользу производительности, жертвуя частью строгой изоляции (разрешая неповторяемые чтения). Другой пример – техника \textbf{снятия блокировок перед коммитом (early lock release)} с помощью специального протокола. Обычно strict 2PL требует держать X- и S-блокировки до конца, но есть подходы, где неконфликтующие блокировки могут быть сняты раньше, если записать в журнал дополнительные сведения для восстановления изоляции при откате. Однако такие алгоритмы довольно сложны и не нашли применения в мейнстрим-СУБД, чаще предпочтительнее использовать MVCC
    \item \textbf{Использование многоверсионности (MVCC)} ~\\
    MVCC сама по себе – метод оптимизации конкуренции, снижающий нагрузку на менеджер блокировок. Благодаря хранению старых версий записей, транзакции читают данные без постановки блокировок и без конфликтов с пишущими транзакциями \autocite{MicrosoftLearnSQLserverTransLock}. Это резко уменьшает общее количество блокировок (особенно Shared-lock для чтения) и, главное, время удержания – читатели не блокируются и не блокируют. Многие современные системы либо целиком перешли на MVCC (PostgreSQL, MySQL/InnoDB, Oracle), либо предлагают её опционально (SQL Server Snapshot Isolation). MVCC не панацея – блокировки всё равно нужны для синхронизации одновременных записей, для предотвращения update-конфликтов и т.п. – но она позволяет оптимизировать самый частый случай: параллельные чтения и изменения одних и тех же данных. Кроме того, MVCC уменьшает вероятность эскалации блокировок, так как долгие чтения больше не держат блокировок, и write-транзакции не накапливают очередь читателей
    \item \textbf{Специальные виды блокировок и протоколов} ~\\
    Разработчики СУБД ввели ряд специальных блокировочных режимов для оптимизации конкретных сценариев. Например, в SQL Server режим U (Update) – позволяющий безопасно читать, а затем обновлять запись, избегая deadlock-а, который мог бы возникнуть при обычных S->X конверсиях. В Oracle есть понятийно схожий механизм: при SELECT FOR UPDATE Oracle ставит сразу X-блокировку на строку (или, точнее, помечает строку как занятую транзакцией), чтобы другие не могли даже читать её из Undo старой версии при Serializable – это упрощает обнаружение конфликтов сериализации (Oracle просто смотрит, не изменилась ли блокируемая строка) ценой краткого блокирования читателей на время SELECT FOR UPDATE. Также Oracle поддерживает \textit{блокировки с понижением} (доуград) для LOB-объектов: крупные объекты можно модифицировать на чтение (LOCK FOR READ) и затем повышать до WRITE. PostgreSQL применяет \textit{predicate locks} (предикатные блокировки) для уровня Serializable на основе SSI – это не классические блокировки, но логические метки, помогающие ловить фантомные чтения, при этом они не блокируют напрямую данные, а служат для последующей проверки конфликтов – то есть оптимизируют сериализуемую изоляцию, избегая избыточной блокировки таблиц. Эти примеры показывают, как глубокая проработка протокола блокировок помогает оптимизировать производительность под разные типы нагрузок (OLTP с частыми короткими транзакциями, long-read транзакции для аналитики и т.д.)
    \item \textbf{Оптимизация в распределённых системах} ~\\
    (Подробнее о централизованном vs распределённом управлении – в следующем пункте.) 
    Здесь отметим, что для распределённых транзакций тоже существуют оптимизации: например, \textit{локальный приоритет} – стараются блокировать ресурс на узле, где транзакция выполняется, а другим узлам давать только <<сигналы>> о блокировке. Некоторые NoSQL/NewSQL системы вообще уходят от явных глобальных блокировок, используя координацию на основе порядковых номеров (timestamps) или функциональное шардирование, где транзакции затрагивают не более одного узла, чтобы не заводить глобальных блокировок. Однако в классических распределённых СУБД (типа Oracle RAC, IBM DB2 PureScale) используются специализированные \textbf{распределённые диспетчеры блокировок} с кэшированием прав владения, быстрой передачей прав узлам по запросу, асинхронным оповещением о снятии блокировки и другими оптимизациями для снижения сетевых задержек при конкурентном доступе.
 \end{itemize} 

 В целом, оптимизация блокировок – это не обязательно <<уменьшение количества блокировок>>, а скорее грамотное управление их уровнем и временем жизни, чтобы минимизировать простой транзакций.

\paragraph{8. Сравнение: централизованное и распределённое управление} ~\\

 Архитектура менеджера блокировок может быть различной в системах с несколькими узлами или экземплярами. Существует два подхода: 
 \begin{itemize}
    \item \textbf{Централизованный менеджер блокировок} ~\\
    Предполагается наличие единого узла (процесса), который отвечает за все блокировки в системе. Все запросы на постановку или снятие блокировки от всех узлов приложения направляются этому центральному менеджеру. Такой подход прост в реализации – фактически, он мало чем отличается от однопользовательской системы, только с удаленными заявками. Преимущество – единое место принятия решений упрощает сохранение целостности: легко вести единый журнал блокировок, просто реализовать обнаружение deadlock (вся информация у нас централизована) \autocite{Silberschatz}. Недостатки – центральный узел может стать \textit{бутылочным горлышком}: при интенсивной нагрузке сетевые и процессорные ресурсы этого узла ограничат производительность всей системы. Кроме того, отказ центрального менеджера блокировок парализует всю систему (проблема надёжности) \autocite{Silberschatz}. Тем не менее, некоторые системы применяют этот подход – например, архитектура с выделенным координационным сервером (в распределённых key-value хранилищах централизованный lock-service можно построить на основе ZooKeeper и подобного). В классических СУБД центральный диспетчер встречался в научных прототипах и в ранних версиях кластеров
    \item \textbf{Распределённый менеджер блокировок} ~\\
    В этом подходе локальные менеджеры блокировок работают на каждом узле (сервере), и каждый отвечает за блокировки \textit{своих} данных. То есть, когда транзакция обращается к данным на узле A, она взаимодействует с локальным lock-manager-ом узла A; если в ходе распределённой транзакции она затрагивает и узел B – тамошний менеджер блокировок занимается своими ресурсами. Такой подход хорошо масштабируется, так как нет единой точки, через которую проходят все заявки – каждый узел обрабатывает только локальные события, нагрузка распределяется \autocite{Silberschatz}. Кроме того, система лучше сопротивляется отказам: сбой одного узла выводит из строя только его часть данных, а блокировки на других узлах продолжают работать (правда, нужно решить судьбу блокировок узла, который упал, но обычно протокол двухфазной фиксации и журналирование помогают откатить или завершить <<висячие>> транзакции на оставшихся узлах). Однако распределённое управление усложняет обнаружение deadlock: возможна ситуация, когда цикл ожидания включает транзакции на разных узлах, причём на каждом отдельном узле локально цикла нет. Например, транзакция $T_1$ на узле 1 ждет ресурс у $T_2$ на узле 2, а $T_2$ на узле 2 – ждет ресурс у $T_1$ на узле 1; ни один локальный менеджер этого не увидит, потому что каждый видит ожидание только <<внешней>> транзакции. Нужно координировать информацию: обычно узлы периодически обмениваются сведениями о своих ожиданиях (строят глобальный wait-for graph) или назначают координатора для проверки циклов между узлами. Это добавляет накладные расходы и сложность алгоритмов. Также возможны более тонкие проблемы: например, транзакции с частичным закреплением ресурсов на разных узлах (не полностью атомарно взяты все блокировки одновременно) могут привести к временным несогласованностям – поэтому распределённые протоколы обычно дополняются двухфазным протоколом блокировок (глобальная двухфазная блокировка – взять все нужные ресурсы на всех узлах, потом работать) и двухфазным протоколом фиксации (2PC), чтобы гарантировать атомарность. Распределённое управление сложнее в реализации, но оно ближе к реальности в современных кластерах: например, Oracle RAC использует \textit{Global Enqueue Service}, который фактически распределён – каждый инстанс Oracle может выступать <<владельцем>> блока данных и управлять его блокировкой, а другие инстансы при необходимости запрашивают разрешение через межузловое взаимодействие. По сути, Oracle RAC реализует \textbf{распределённый диспетчер блокировок (Distributed Lock Manager, DLM)} \autocite{oracleessentialsc7}. Преимущество – отказ одного узла RAC не приводит к полной остановке: его блокировки просто освобождаются или передаются другим узлам; недостаток – узлы тратят ресурсы на согласование (глобальный обмен сообщениями при конкуренции за один ресурс)
 \end{itemize} 
 
 \textbf{Вывод сравнения} ~\\
 Централизованное управление проще и иногда быстрее на малом количестве узлов, но плохо масштабируется и имеет единую точку отказа. Распределённое – масштабируется и устойчиво к отказам отдельных узлов, но требует более сложных протоколов для обеспечения - необходимо решить проблему глобальных deadlock, обеспечить атомарность транзакций через 2PC и т.д. \autocite{Silberschatz}. 
 
 В реальных системах часто используются гибридные подходы. Например, может быть выделен один узел, хранящий глобальный каталог блокировок (централизованно), но при этом сами проверки совместимости делаются распределённо – либо каждый узел отвечает за свой раздел данных (partitioned lock manager). 
 
 Другой вариант – иерархия диспетчеров: несколько региональных координаторов, подчинённых глобальному. Также иногда применяются отказоустойчивые центральные координаторы (кластеризованный менеджер блокировок с репликацией на резервный узел). Все эти схемы направлены на то, чтобы снять ограничения простого центрального подхода, сохранив при этом целостность данных. При проектировании распределённой СУБД инженеры выбирают компромисс между сложностью и производительностью. Например, система может отказаться от глобальных блокировок вовсе, используя вместо них мультверсии и рассылку изменений (как в некоторых NewSQL), но это уже отклонение от классической модели транзакций. Для distributed-СУБД критически важно также оптимизировать сетевые задержки: даже если менеджер блокировок распределён, каждая межузловая заявка на блокировку – это сообщение по сети. Поэтому в высокопроизводительных кластерах стараются минимизировать такие обращения: используют \textit{локальное кеширование блокировок} (когда узел помнит, что у него есть эксклюзивное право на какой-то блок данных, и может повторно разрешать локальные запросы без повторного оповещения всех узлов), объединяют несколько действий в одно сообщение, применяют специальные сети с низкой задержкой (InfiniBand, RDMA) для ускорения передачи блокировочных сообщений. Пример – упомянутый DLM в VAX VMS или Oracle RAC, где узлы обмениваются сообщениями о блокировках через быструю межсоединительную сеть; ещё пример – Microsoft SQL Server в режиме кластеризации AlwaysOn использует распределённые блокировки для координации доступа к разделяемым файлам, однако в режиме <<Availability Groups>> фактически избегает распределённых транзакций, держа каждую транзакцию на одном узле. Таким образом, централизованное и распределённое управление блокировками – два полюса с точки зрения архитектуры: первое проще, второе масштабируемее. 
 
 Практические реализации стараются получить лучшее из обоих миров, но всегда присутствует компромисс. Выбор подхода зависит от требований системы: для односерверной СУБД естественно централизованное управление (в пределах одного процесса), для мультисерверного кластера – придётся распределять эту функцию между узлами. Главное – обеспечить корректность (единые правила совместимости, отсутствие пропущенных разблокировок) и приемлемую эффективность в целевом окружении, будь то один мощный сервер или десятки узлов в распределённой БД.

\subsection{Контроль целостности на уровне СУБД}
\subsubsection{Ограничения целостности}

 Ограничения целостности — это правила, гарантирующие корректность и согласованность данных в базе данных. Как отмечают Silberschatz с соавторами, такие ограничения служат защитой от случайного повреждения базы: они не позволяют даже санкционированным изменениям привести к потере согласованности данных \autocite{Silberschatz}. Иначе говоря, СУБД не даст выполнить операцию, если из-за неё данные перестанут удовлетворять заданным ограничениям. Принято различать логическую и физическую целостность данных. Логическая целостность относится к смысловой правильности информации: все значения должны соответствовать своим допустимым доменам, а связи между записями — оставаться корректными. Физическая же целостность связана с сохранностью данных на уровне хранения и защиты от сбоев (аппаратных или программных). 
 
 В современных СУБД физическая целостность обеспечивается механизмами резервного копирования, транзакций, журналирования и т.п., тогда как логическая поддерживается за счёт системы ограничений на уровне модели данных. Основные виды логических ограничений целостности включают доменные ограничения, целостность сущностей и ссылочную целостность \autocite{ElmasriNavathe}. Доменные ограничения определяют допустимые значения для каждого атрибута — они задаются типами данных столбцов, допустимыми форматами или явными условиями (например, ограничение возраста диапазоном от 0 до 120 лет). Ограничение целостности сущности означает, что каждая запись в таблице уникально идентифицируется ключом и этот ключ не может принимать NULL-значение (первичный ключ записи не должен быть NULL) \autocite{ElmasriNavathe}. Наконец, ограничение ссылочной (референциальной) целостности требует, чтобы каждое значение внешнего ключа ссылалось на существующую запись в связанной таблице; если связь необязательна, внешнему ключу может быть присвоено значение NULL, но недопустимо указание несуществующего объекта \autocite{ElmasriNavathe}. 

 В реляционных СУБД поддерживаются следующие базовые ограничения целостности (задаются в определении схемы таблицы): 
 \begin{itemize}
    \item \textbf{NOT NULL} — запрещает отсутствие значения в указанном столбце. Если столбец объявлен с \texttt{NOT NULL}, при попытке вставить в него значение NULL или пропустить этот столбец в INSERT, СУБД отклонит такую операцию.
    \item \textbf{CHECK} — проверочное ограничение, задающее произвольное условие, которому должны удовлетворять значения. Условие определяется выражением (логическим), которое вычисляется для каждой строки. Например, можно потребовать CHECK (salary \textgreater 0) для столбца с зарплатой, чтобы не допустить отрицательных значений. Попытка вставить или обновить данные, нарушающие условие CHECK, вызовет ошибку.
    \item \textbf{UNIQUE} — ограничение уникальности. Гарантирует, что все значения в указанном столбце (или комбинации столбцов) будут различны, то есть не будет двух строк с одинаковым значением этого поля (или набора полей). Ограничение UNIQUE похоже на первичный ключ, но отличается тем, что может применяться к нескольким столбцам в таблице (альтернативные ключи) и допускает одно NULL-значение (если бизнес-правила это позволяют). При нарушении уникальности (например, повторное значение при вставке) операция будет отклонена.
    \item \textbf{PRIMARY KEY} — первичный ключ. Это ограничение сочетает в себе уникальность и отсутствие NULL: первичный ключ однозначно идентифицирует запись и не может быть пустым. В каждой таблице, как правило, выделяется один первичный ключ (может состоять из одного или нескольких столбцов). СУБД не позволит вставить более одной строки с одинаковым значением PK, а также запретит NULL в полях, входящих в состав PK.
    \item \textbf{FOREIGN KEY} — внешний ключ. Это ограничение ссылочной целостности, устанавливающее связь между двумя таблицами: значение внешнего ключа в дочерней таблице должно существовать как значение первичного (или кандидата на ключ) в родительской таблице. Таким образом, внешние ключи предотвращают появление <<висящих>> ссылок. По умолчанию, при попытке вставить в дочернюю таблицу ссылку на несуществующую родительскую запись или удалить родительскую запись, на которую ещё есть ссылки, СУБД вызовет ошибку и отклонит такое действие \autocite{Silberschatz}. (SQL также позволяет задать специальные меры при таких операциях, например каскадное удаление или автоматическую установку значения по умолчанию, но по умолчанию любые нарушения ссылочной целостности запрещены.)
 \end{itemize} 

 Рассмотрим пример. Пусть требуется создать две таблицы — отделы и сотрудники — с использованием перечисленных ограничений целостности (первичный ключ, внешние ключи, и др.). Определение схемы может выглядеть так: 
 \begin{lstlisting}[language=SQL]
    CREATE TABLE Departments (
    DeptID INT,
    DeptName VARCHAR(100),
    CONSTRAINT PK_Dep PRIMARY KEY (DeptID),
    CONSTRAINT UQ_DepName UNIQUE (DeptName)
    ); 
    CREATE TABLE Employees (
    EmpID INT,
    EmpName VARCHAR(100) NOT NULL,
    DeptID INT,
    Salary DECIMAL(10,2),
    CONSTRAINT PK_Emp PRIMARY KEY (EmpID),
    CONSTRAINT FK_Emp_Dep FOREIGN KEY (DeptID)
    REFERENCES Departments(DeptID),
    CONSTRAINT CHK_Salary CHECK (Salary >= 0)
    );
 \end{lstlisting}

 В этом примере столбец \texttt{EmpName} помечен как NOT NULL (требуется имя для каждого сотрудника), ограничение \texttt{CHK\_Salary} не позволяет хранить отрицательную зарплату, ограничение уникальности \texttt{UQ\_DepName} запрещает повторять названия отделов, \texttt{PK\_Dep} и \texttt{PK\_Emp} определяют первичные ключи, а внешний ключ \texttt{FK\_Emp\_Dep} гарантирует, что значение \texttt{DeptID} у сотрудника ссылается на существующий отдел. Если попытаться вставить данные, нарушающие эти правила (например, сотрудника с несуществующим \texttt{DeptID} или двумя сотрудниками с одинаковым \texttt{EmpID}), СУБД откажется выполнить такую операцию. Состояние базы данных, которое не удовлетворяет хотя бы одному из заданных ограничений, считается недопустимым (невалидным) \autocite{ElmasriNavathe}, поэтому система отклоняет изменения, ведущие к нарушению целостности.


\subsubsection{Реализация ограничений в различных СУБД}

 Рассмотрим, как современные СУБД обеспечивают контроль целостности на уровне ограничения, и где хранится информация о заданных ограничениях в системных каталогах каждой СУБД. 

\paragraph{PostgreSQL} ~\\

 PostgreSQL полностью поддерживает перечисленные ограничения при определении схемы таблиц. Например, создадим таблицы с ограничениями, аналогичными приведённым выше.
 
 После создания таблиц, информация о заданных ограничениях сохранена в системе каталогов PostgreSQL — в частности, в таблице \texttt{pg\_constraint} хранятся сведения обо всех ограничениях типа CHECK, UNIQUE, PRIMARY KEY и FOREIGN KEY для таблиц базы данных \autocite{PostgreSQLdocc51}. (Заметим, что ограничение NOT NULL относится к свойству столбца и учитывается в каталоге столбцов.) Если приложение попытается вставить или обновить данные вопреки ограничениям (например, вставить сотрудника с несуществующим значением \texttt{DeptID} или задать NULL в поле \texttt{EmpName}), PostgreSQL предотвратит нарушение: операция будет отменена с сообщением об ошибке (например, \texttt{ERROR: insert or update on table "Employees" violates foreign key constraint "FK\_Emp\_Dep"}). Таким образом, механизм ограничений на уровне СУБД гарантирует сохранение целостности данных

\paragraph{MySQL} ~\\

 В MySQL ограничения целостности также задаются при создании таблиц аналогичным SQL-синтаксисом.

 Внутренняя реализация ограничений в MySQL основана на стандартной информационной схеме (\texttt{INFORMATION\_SCHEMA}). Метаданные обо всех заданных ограничениях можно получить из таблиц информационной схемы, таких как \texttt{TABLE\_CONSTRAINTS} (список ограничений в каждой таблице) и \texttt{KEY\_COLUMN\_USAGE} (описание столбцов, участвующих в ключевых ограничениях) \autocite{Mysqldoc1}. Например, в \texttt{TABLE\_CONSTRAINTS} для созданных выше таблиц будут записи с типами \texttt{PRIMARY KEY}, \texttt{UNIQUE} и \texttt{FOREIGN KEY} для соответствующих ограничений. MySQL будет пресекать любые действия, нарушающие целостность: при попытке вставить повторяющееся значение уникального ключа или несуществующий внешний ключ СУБД вернёт ошибку (например, <<Error Code 1062: Duplicate entry \ldots for key \texttt{UQ\_DepName}>> или <<Error Code 1452: Cannot add or update a child row: a foreign key constraint fails>>), и операция не выполнится. 

\paragraph{Microsoft SQL Server} ~\\ 

 В Microsoft SQL Server ограничения аналогично определяются в DDL таблицы. Например:
 \begin{lstlisting}[language=SQL]
    CREATE TABLE Departments (
    DeptID INT PRIMARY KEY,
    DeptName VARCHAR(100) UNIQUE
    );
    CREATE TABLE Employees (
    EmpID INT PRIMARY KEY,
    EmpName VARCHAR(100) NOT NULL,
    DeptID INT,
    Salary DECIMAL(10,2) CHECK (Salary >= 0),
    CONSTRAINT FK_Emp_Dep FOREIGN KEY (DeptID)
    REFERENCES Departments(DeptID)
    );
 \end{lstlisting}

 Здесь был использован сокращённый синтаксис (объявляя первичный ключ и уникальность непосредственно в описании столбцов). В системном каталоге SQL Server информация об ограничениях доступна через представления каталога: например, представление \texttt{sys.key\_constraints} содержит по одной записи на каждый первичный или уникальный ключ \autocite{msSysKeyConstraints}, \texttt{sys.check\_constraints} — по каждому CHECK-условию, а \texttt{sys.foreign\_keys} — по каждому ограничению внешнего ключа (с детализацией столбцов в \texttt{sys.foreign\_key\_columns}). При нарушении любого из ограничений SQL Server прерывает выполнение запроса и генерирует ошибку. Например, попытка вставить строку в \texttt{Employees} с несуществующим \texttt{DeptID} вызовет ошибку уровня сервера: \enquote{The INSERT statement conflicted with the FOREIGN KEY constraint \texttt{FK\_Emp\_Dep}} (с указанием имени ограничения и сути конфликта), и такая запись не будет добавлена в таблицу. 

\paragraph{Oracle} ~\\

 СУБД Oracle также поддерживает стандартные ограничения целостности при определении таблиц. Метаданные об ограничениях в Oracle хранятся в системном словаре (data dictionary). Например, во view \texttt{DBA\_CONSTRAINTS} содержатся все ограничения, определённые в базе данных (аналогично \texttt{USER\_CONSTRAINTS} для текущего пользователя) \autocite[§4.216]{oracledbdoc1}. В столбце \texttt{CONSTRAINT\_TYPE} этого словаря указывается тип ограничения (\texttt{C} — check, \texttt{P} — primary key, \texttt{U} — unique, \texttt{R} — referential (foreign key) и т.д.). При выполнении операций Oracle автоматически проверяет все заданные ограничения: если, скажем, вставляемое или обновляемое значение нарушает условие CHECK или ссылочную целостность, СУБД отклонит операцию и сгенерирует ошибку (например, \texttt{ORA-02290} при нарушении CHECK или \texttt{ORA-02291} при нарушении внешнего ключа), не допуская несогласованных данных.

\subsection{Правила (триггеры)}

 Триггер – это специальная процедура (кусок кода), который СУБД автоматически выполняет при наступлении определённого события, такого как изменение данных в таблице \autocite{Silberschatz}. Иначе говоря, триггер срабатывает при наступлении заданного \textbf{события} и при выполнении опционального \textbf{условия}, выполняя заданное \textbf{действие} (так называемое правило типа <<событие-условие-действие>>) \autocite{ElmasriNavathe}. 
 
 Триггеры были стандартизированы в SQL:1999, хотя в каких-то СУБД они существовали и ранее (с использованием собственного синтаксиса) \autocite{Silberschatz}. Триггеры широко применяются для поддержания целостности сложных бизнес-правил, ведения журналов изменений (аудита), реализации вычисляемых столбцов или поддержания денормализованных данных, а также для реализации контроля безопасности (например, запрет или протоколирование определённых действий). В данном разделе рассматриваются различные типы триггеров и особенности их поддержки в PostgreSQL, MySQL, Microsoft SQL Server и Oracle.

\subsubsection{Типы триггеров и их применение}

 Существуют несколько классификаций триггеров. Во-первых, \textbf{триггеры DML} срабатывают при операциях модификации данных (Data Manipulation Language) – таких как \texttt{INSERT}, \texttt{UPDATE}, \texttt{DELETE} – на таблицах или представлениях. Во-вторых, \textbf{триггеры DDL} реагируют на события изменения схемы базы данных (Data Definition Language), например создание или удаление таблиц и других объектов. Отдельно можно выделить \textbf{триггеры \textit{INSTEAD OF}}, которые срабатывают вместо указанного события (чаще всего используются для представлений), и \textbf{системные триггеры}, привязанные к событиям уровня системы или базы данных (например, вход пользователя в систему). 
 
 Ниже мы подробно рассмотрим каждый вид триггеров, их синтаксис, порядок выполнения, ограничения и применение в разных СУБД. Важно понимать разделение триггеров по моменту срабатывания относительно события: многие СУБД поддерживают триггеры, выполняющиеся \textbf{до} события или \textbf{после} него в случае DML-операций. Например, \texttt{BEFORE} - триггер может изменить или проверить данные перед их сохранением, выступая как дополнительное ограничение \autocite{Silberschatz}. Также в стандартном SQL предусмотрены \textbf{строковые триггеры} (срабатывают для каждой затронутой строки, англ. \textit{row-level}) и \textbf{триггеры уровня оператора} (срабатывают один раз на весь оператор, англ. \textit{statement-level}) \autocite{Silberschatz}. 
 
 На практике поддержка этих вариантов различается между СУБД, о чём будет сказано ниже. В триггерах, особенно DML-триггерах, обычно доступны специальные псевдозначения: <<старые>> и <<новые>> значения изменяемых строк (\texttt{OLD}, \texttt{NEW}), которые позволяют сравнить состояние данных до и после изменения \autocite{Silberschatz}. Ниже, перейдя к конкретным видам триггеров, мы рассмотрим эти аспекты подробней для каждой СУБД.

\subsubsection{DML-триггеры (на операции с данными)}

 DML-триггеры предназначены для автоматического выполнения действий при изменении данных в таблицах. Они могут срабатывать до или после вставки, обновления или удаления строк. Некоторые СУБД (например, Oracle, PostgreSQL) поддерживают как построчные, так и операционные триггеры, тогда как другие (например, MySQL) фактически позволяют только построчные триггеры. Рассмотрим особенности DML-триггеров в различных СУБД:

 \paragraph{\textbf{PostgreSQL}} ~\\

 В PostgreSQL триггеры реализованы через механизм вызова пользовательской функции, возвращающей специальный тип \texttt{trigger} \autocite{Postgresqlcom}. Синтаксис создания триггера включает указание момента срабатывания (\texttt{BEFORE}/\texttt{AFTER}/\texttt{INSTEAD OF}), события (\texttt{INSERT}, \texttt{UPDATE} \textit{[OF columns]}, \texttt{DELETE} или даже \texttt{TRUNCATE}) и уровня срабатывания (\texttt{FOR EACH ROW} или \texttt{FOR EACH STATEMENT})  \autocite{Postgresqlcom}. Триггер привязывается к таблице или представлению и при наступлении события вызывает заданную функцию-обработчик \autocite{Postgresqlcom}. В теле функции можно обращаться к данным изменяемой строки через \texttt{NEW} и \texttt{OLD} (для \texttt{INSERT}/\texttt{UPDATE} и \texttt{UPDATE}/\texttt{DELETE} соответственно). Ниже приведён пример создания триггера в PostgreSQL, который при добавлении сотрудника автоматически заносит запись в таблицу аудита:
 \begin{lstlisting}[language=SQL]
    CREATE OR REPLACE FUNCTION log_new_employee()
    RETURNS trigger AS $$
    BEGIN
        INSERT INTO employees_audit(emp_id, action, time)
        VALUES(NEW.id, 'INSERT', now());
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER trg_log_emp_insert
    BEFORE INSERT ON employees
    FOR EACH ROW
    EXECUTE FUNCTION log_new_employee();
 \end{lstlisting}

 В этом примере \texttt{BEFORE INSERT} - триггер на таблице \texttt{employees} вызывает функцию, которая добавляет запись о новом сотруднике в таблицу \texttt{employees\_audit}. \texttt{RETURN NEW} в конце функции необходим, чтобы вставляемая строка не терялась (для \texttt{BEFORE}-триггеров PostgreSQL ожидает вернуть новую или модифицированную строку, либо \texttt{NULL} для отмены операции)  \autocite{Postgresqltrig}. PostgreSQL позволяет определять несколько триггеров на одно и то же событие — они будут выполняться по алфавитному порядку имени триггера \autocite{Postgresqlcom}. (Стандарт SQL предписывает упорядочивать по времени создания, однако PostgreSQL выбрал порядок по имени как более удобный \autocite{Postgresqlcom}). Если определено несколько \texttt{BEFORE}-триггеров, каждый может модифицировать строку для следующих триггеров; если какой-либо вернёт \texttt{NULL}, оставшаяся часть операции (и другие триггеры) отменяется \autocite{Postgresqltrig}. PostgreSQL не накладывает жёсткого ограничения на глубину вызова триггеров: триггер может выполнить SQL-команду, которая вызовет срабатывание других триггеров (каскадное срабатывание). При этом возможно и рекурсивное вызово самого себя (например, \texttt{INSERT}-триггер вставляет новую строку в ту же таблицу) — никакого встроенного предела уровней вложенности нет, разработчик должен сам предотвращать бесконечную рекурсию логикой в коде \autocite{Postgresqltrig}. 
 
 В случае бесконечного цикла в конечном итоге будет переполнение стека или превышение глубины рекурсии, поэтому важно. предусматривать условия выхода.

\paragraph{\textbf{MySQL}} ~\\

 MySQL поддерживает DML-триггеры начиная с версии 5.0. Синтаксис немного проще: триггер привязывается к конкретной таблице и одному из событий \texttt{INSERT}, \texttt{UPDATE} или \texttt{DELETE}, с указанием \texttt{BEFORE} или \texttt{AFTER} \autocite{Mysqldoc5}. Триггеры в MySQL всегда построчные (\texttt{FOR EACH ROW} обязательно и указывается неявно); триггерное тело задаётся как блок \texttt{BEGIN \ldots END} с SQL-командами. Например, создадим триггер для протоколирования изменений зарплаты сотрудника в таблицу аудита:

 \begin{lstlisting}[language=SQL]
    CREATE TRIGGER trg_log_salary_change
    AFTER UPDATE ON employees
    FOR EACH ROW
    BEGIN
        INSERT INTO salary_audit(emp_id, old_salary, new_salary, changed_at)
        VALUES(OLD.id, OLD.salary, NEW.salary, NOW());
    END;
 \end{lstlisting}

 Этот триггер срабатывает после каждого \texttt{UPDATE} строки таблицы \texttt{employees}. Он берёт \texttt{OLD.salary} и \texttt{NEW.salary} и записывает их, например, в таблицу \texttt{salary\_audit} вместе с меткой времени. В теле триггера доступны псевдозаписи \texttt{OLD} и \texttt{NEW} аналогично другим СУБД \autocite{Mysqldoc5}. 
 
 MySQL до версии 8.0 ограничивал количество триггеров - можно было создать не более одного \texttt{BEFORE} и одного \texttt{AFTER} триггера для каждой комбинации событие-таблица. В современных версиях (8.0+) ограничение снято – допускается несколько триггеров на одно событие, и для упорядочивания их выполнения используется опциональная опция-конструкция \texttt{FOLLOWS} или \texttt{PRECEDES} (либо по умолчанию триггеры выполняются в порядке создания) \autocite{Mysqldoc5}.
 
 Существенные ограничения MySQL: триггеры \textbf{не поддерживаются на представлениях или временных таблицах}, и внутри триггера \textbf{запрещено выполнять изменения той же таблицы}, которая вызвала триггер (иначе говоря, триггер не может напрямую модифицировать <<свою>> таблицу) \autocite{Mysqldoc6}. Последнее ограничение предотвращает рекурсивное срабатывание триггера и потенциальные бесконечные циклы: если попытаться в триггере на \texttt{employees} выполнить, например, \texttt{UPDATE employees \ldots}, СУБД выдаст ошибку. Кроме того, в MySQL есть ряд ограничений на используемые в триггерах конструкции (нельзя применять \texttt{CALL} для хранимых процедур, запрещены транзакционные команды типа \texttt{COMMIT} или \texttt{CREATE/DROP TABLE} внутри триггера и др.). Несмотря на эти ограничения, триггеры MySQL пригодны для задач аудита и простых бизнес-правил, которые нельзя выразить ограничениями. Например, выше показанный триггер аудита изменений – типичный кейс для MySQL.

 \paragraph{\textbf{SQL Server}} ~\\

 В Microsoft SQL Server триггеры реализованы как особый вид хранимых процедур, которые автоматически выполняются при наступлении события в базе данных. В Transact-SQL создаются два типа DML-триггеров: \texttt{AFTER}-триггеры (их можно указывать ключевым словом \texttt{AFTER} или словом \texttt{FOR}, по умолчанию считаются \texttt{AFTER}) и \texttt{INSTEAD OF}-триггеры (о них ниже) на таблицах или представлениях. \texttt{BEFORE} (до события) триггеров в классическом SQL Server нет – вместо них для валидации данных обычно используются \texttt{CHECK}-ограничения или \texttt{INSTEAD OF} триггеры, либо проверка в самом приложении. DML-триггеры в SQL Server по своей природе являются операционными: триггер срабатывает один раз на весь SQL-оператор, а не на каждую строку. Поэтому внутри триггера вместо \texttt{OLD}/\texttt{NEW} доступна так называемая \textbf{модель множественных строк}, где изменения предоставляются через временные таблицы \texttt{inserted} и \texttt{deleted}. Таблица \texttt{inserted} содержит новые версии добавленных/обновлённых строк, \texttt{deleted} – старые версии удалённых/обновлённых строк. Тело триггера обычно написано на T-SQL. Рассмотрим простой пример \texttt{AFTER}-триггера на таблице \texttt{employees}, аналогичный предыдущим примерам аудита.

 \begin{lstlisting}[language=SQL]
    CREATE TRIGGER trg_log_salary_change
    ON dbo.Employees
    AFTER UPDATE
    AS
    BEGIN
        INSERT INTO dbo.SalaryAudit(emp_id, old_salary, new_salary, changed_at)
        SELECT d.id, d.salary, i.salary, SYSUTCDATETIME()
        FROM inserted AS i
        JOIN deleted AS d ON i.id = d.id;
    END;
 \end{lstlisting}

Здесь триггер срабатывает после \texttt{UPDATE} на таблице \texttt{Employees}. Он выбирает старые и новые значения зарплаты из таблиц \texttt{deleted} (псевдотаблица со старыми значениями) и \texttt{inserted} (с новыми значениями) и помещает их в таблицу аудита \texttt{SalaryAudit}. Обратите внимание: если оператор \texttt{UPDATE} изменил сразу несколько строк, триггер всё равно выполнится один раз, и в таблицах \texttt{inserted}/\texttt{deleted} будет несколько строк — поэтому пример использует операцию \texttt{JOIN}, чтобы сопоставить старые и новые значения по идентификатору сотрудника. Такой подход по сравнению с построчными триггерами обеспечивает эффективность при массовых обновлениях.

SQL Server допускает множество триггеров на одно событие (например, несколько разных \texttt{AFTER UPDATE} триггеров на одной таблице). Порядок их выполнения по умолчанию не гарантируется, однако администратор может указать порядок, пометив один из триггеров как \texttt{FIRST} или \texttt{LAST} для данного события через системную хранимую процедуру \texttt{sp\_settriggerorder} (иначе порядок остаётся неопределённым) \autocite{MicrosoftLearnDDLTrig}.

Что касается вложенных и рекурсивных триггеров, SQL Server по умолчанию позволяет каскадное срабатывание: если в триггере выполнить операцию, она может вызвать другие триггеры. Максимальная глубина вложенности триггерных вызовов – 32 уровня  \autocite{MicrosoftLearnNestTrig}; попытка уйти глубже вызовет ошибку и откат транзакции. При необходимости администратор может отключить каскадное срабатывание триггеров на сервере (параметр сервера \texttt{nested triggers}) или запретить именно прямую рекурсию (параметр базы данных \texttt{RECURSIVE\_TRIGGERS}). По умолчанию прямой рекурсии нет: если триггер пытается изменить ту же таблицу, на которой он висит, повторный вызов триггера не произойдёт (то есть, в отличие от PostgreSQL, SQL Server сам предотвращает немедленную рекурсию). Однако косвенная вложенность триггеров (через изменения в других таблицах) поддерживается и часто используется, например, для каскадного обновления связанных таблиц. Разработчику нужно учитывать возможность множественного срабатывания триггеров и тщательно тестировать логику, чтобы избежать неожиданных циклов.

\paragraph{\textbf{Oracle}} ~\\

 Oracle Database поддерживает мощный гибкий механизм триггеров. DML-триггеры в Oracle могут быть \texttt{BEFORE} или \texttt{AFTER}, а также действовать либо по каждой строке (\texttt{FOR EACH ROW}), либо по всему оператору (если \texttt{FOR EACH ROW} не указано). Oracle позволяет в одном триггере указать несколько событий сразу, например \texttt{CREATE TRIGGER \ldots BEFORE INSERT OR UPDATE OR DELETE ON Table \ldots}. 
 
 Внутри триггера для построчных триггеров доступны псевдозаписи \texttt{:OLD} и \texttt{:NEW} (с двоеточием, так как синтаксис PL/SQL) для обращения к старым и новым значениям полей. Ниже приведён простой пример \texttt{AFTER}-триггера на таблице \texttt{employees}, который проверяет и корректирует данные:
 \begin{lstlisting}[language=SQL]
    CREATE OR REPLACE TRIGGER trg_check_salary
    BEFORE INSERT OR UPDATE OF salary
    ON employees
    FOR EACH ROW
    WHEN (NEW.job_id <> 'CEO')
    BEGIN
        IF :NEW.salary > 100000 THEN
            :NEW.salary := 100000;
        END IF;
    END;
 \end{lstlisting}

 Здесь триггер срабатывает перед вставкой новой записи сотрудника или обновлением зарплаты существующего (\texttt{UPDATE OF salary}). Если должность не \texttt{CEO}, то при превышении зарплаты выше 100000 она автоматически снижется до этого порога. Условие \texttt{WHEN} позволяет задать дополнительный фильтр для срабатывания триггера на уровне каждого изменения. Обратим внимание, Oracle допускает внутри триггера изменять значения \texttt{:NEW} (в \texttt{BEFORE}-триггере), что фактически корректирует вставляемые/изменяемые данные перед их записью.
 
 Oracle до версии 11g допускал не более одного триггера каждого типа (например, одного \texttt{BEFORE ROW INSERT} триггера) на таблицу. Начиная с Oracle 11g появилась возможность создавать несколько триггеров одного типа, определяя явный порядок их срабатывания с помощью ключевых слов \texttt{FOLLOWS}/\texttt{PRECEDES}  \autocite{oracledbdoc6}. Если порядок не задан явно, то при наличии нескольких триггеров одного типа порядок их вызова не определён (может различаться). Oracle, подобно SQL Server, ограничивает максимальную каскадную вложенность триггеров 32 уровнями по умолчанию  \autocite{oracledbdoc8}. 
 
 Также в Oracle существует механизм предотвращения некоторых видов <<порочных>> триггеров: если в теле \texttt{ROW}-триггера попытаться обратиться к той же таблице (например, выбрать или изменить данные той же таблицы), Oracle выдаст ошибку уровня выполнения (ORA-04091 <<mutating table>>), считая, что таблица <<изменяется, и к ней нельзя обращаться>>. Это ограничение (известное как проблема <<изменяющейся таблицы>>) существует чтобы предотвратить некорректные чтения несформированных данных и потенциальную рекурсию. Для обхода этого ограничения приходится использовать либо \texttt{STATEMENT}-триггеры, либо хранение изменений во временных структурах и т.п. В целом, Oracle-триггеры очень мощные: помимо базовых DML-триггеров, Oracle предоставляет и другие их виды, которые рассмотрим далее.

\subsubsection{DDL-триггеры (триггеры на изменения схемы)}

 DDL-триггеры позволяют отловить и обработать события изменения структуры базы данных: создание, изменение или удаление объектов (таблиц, схем, пользователей и др.), а также другие команды DDL. Такие триггеры обычно используются для аудита (журналирования) действий администраторов или для реализации дополнительных правил безопасности (например, запрет определённых операций).

\paragraph{\textbf{PostgreSQL}} ~\\

 В PostgreSQL начиная с версии 9.3 введён механизм \textit{event triggers} (триггеры событий), который по сути реализует функциональность DDL-триггеров. Event trigger создаётся командой \texttt{CREATE EVENT TRIGGER} и привязывается к определённому событию DDL, например \texttt{ddl\_command\_start} или \texttt{ddl\_command\_end}, с фильтрацией по типу команды (через \texttt{WHEN tag IN (\ldots)}). В теле event trigger’а доступна функция \texttt{pg\_event\_trigger\_ddl\_commands()} для получения списка произошедших изменений, или функция \texttt{pg\_event\_trigger\_sql\_text()} для получения текста DDL. Таким образом, PostgreSQL позволяет отлавливать события типа \texttt{CREATE TABLE}, \texttt{DROP FUNCTION} и т.п. на уровне базы. 

 Применение: аудит (например, записывать в свою таблицу все \texttt{DROP TABLE}), синхронизация схемы с внешними системами, контроль неопределённых DDL-операций. Однако, event triggers в PostgreSQL работают немного иначе, чем привычные DDL-триггеры в Oracle/SQL Server: они срабатывают на уровне начала или окончания любого DDL-оператора, и пока их набор событий несколько ограничен (например, нет event trigger прямо на <<любое CREATE>> – приходится обрабатывать через общие события). Пример использования event trigger:

 \begin{lstlisting}[language=SQL]
    CREATE EVENT TRIGGER trg_ddl_audit
    ON ddl_command_end
    WHEN TAG IN ('CREATE TABLE', 'DROP TABLE')
    EXECUTE FUNCTION log_ddl_event();
 \end{lstlisting}

 Здесь \texttt{log\_ddl\_event()} – это пользовательская функция, которая могла бы, например, получать через \texttt{pg\_event\_trigger\_ddl\_commands()} информацию о DDL-операции и заносить её в журнал. Важно отметить, что обычные \texttt{CREATE TRIGGER} (как в разделе DML) не применяются к DDL – для этих целей служит отдельная команда event trigger. PostgreSQL не поддерживает триггеры на вход/выход пользователя или другие системные события помимо DDL.

\paragraph{\textbf{MySQL}} ~\\

 MySQL \textbf{не поддерживает} DDL-триггеры. Нельзя создать триггер, срабатывающий на \texttt{CREATE}, \texttt{ALTER}, \texttt{DROP} или подобные команды. Контроль подобных операций в MySQL осуществляется другими средствами (например, через права пользователей, журналирование на уровне сервера, либо посредством ручного отслеживания \texttt{information\_schema} или binlog-а). Таким образом, в графе поддержки DDL-триггеров у MySQL стоит <<нет>>.

\paragraph{\textbf{SQL Server}} ~\\

 SQL Server поддерживает DDL-триггеры начиная с версии 2005. DDL-триггер создаётся командой \texttt{CREATE TRIGGER} похожим образом, но указывается не таблица, а ключевые слова \texttt{ON DATABASE} или \texttt{ON ALL SERVER} вместо имени таблицы. Также указывается через \texttt{FOR} список событий DDL (или слово \texttt{ALL DDL EVENTS}). Например, можно написать:

 \begin{lstlisting}[language=SQL]
    CREATE TRIGGER trg_prevent_drop
    ON DATABASE
    FOR DROP_TABLE, ALTER_TABLE
    AS
    BEGIN
        PRINT 'Dropping or altering tables is not allowed!';
        ROLLBACK;
    END;
 \end{lstlisting}

Этот триггер на уровне базы данных будет срабатывать при попытке удалить или изменить любую таблицу в данной базе и отменять эту операцию (\texttt{ROLLBACK}) после вывода предупреждения. DDL-триггеры в SQL Server всегда выполняются \textbf{после} соответствующего события (аналог \texttt{AFTER}, других вариантов нет)  \autocite{MicrosoftLearnDDLTrig}. Естественно, если триггер делает \texttt{ROLLBACK}, он откатывает сам факт события. В DDL-триггерах недоступны таблицы \texttt{inserted}/\texttt{deleted} (так как событие не связано напрямую с конкретными записями) \autocite{MicrosoftLearnDDLTrig}. Вместо этого SQL Server предоставляет функцию \texttt{EVENTDATA()}, которая возвращает XML с описанием произошедшего события (какой оператор, какой объект затронут, кто пользователь и т.д.) \autocite{MicrosoftLearnDDLTrig}. Разобрав XML, триггер может принять нужное решение. 
Например, можно журналировать все DDL-изменения, записывая из \texttt{EVENTDATA()} нужные поля в таблицу аудита. DDL-триггеры могут быть как базы данных (\texttt{ON DATABASE}, реагируют на события в конкретной БД), так и серверные (\texttt{ON ALL SERVER}, реагируют на события в масштабе всего экземпляра SQL Server, например создание нового входа \texttt{LOGIN} или изменение любой базы данных).

Количество DDL-триггеров на одно событие не ограничено (можно несколько на одно событие). Они, как и DML, могут быть помечены как \texttt{FIRST}/\texttt{LAST} для упорядочения, иначе порядок неопределённый \autocite{MicrosoftLearnDDLTrig}. В отличие от DML-триггеров, у DDL-триггеров нет привязки к схеме, они существуют либо в контексте базы, либо сервера \autocite{MicrosoftLearnDDLTrig}. Также, как отмечалось ранее, DDL-триггеры могут участвовать в цепочках вложенных триггеров: например, DDL-триггер на создание таблицы может внутри себя выполнить инструкцию DML (например, вставку в таблицу журнала), что вызовет DML-триггер, и т.д. Здесь тоже действует общее ограничение 32 уровня вложенности для всех видов триггеров в SQL Server \autocite{MicrosoftLearnNestTrig}.

Применение DDL-триггеров SQL Server разнообразно: аудит (отслеживание изменений схемы, кто и когда что сделал), безопасность (запрет нежелательных действий, как показано выше), автоматизация администрирования (например, ловить событие \texttt{CREATE USER} и сразу выдавать этому пользователю какие-то права через код в триггере) и пр. Следует помнить, что злоумышленник с административными правами может отключить или удалить DDL-триггеры, поэтому на 100\% как средство безопасности на них полагаться нельзя – однако для внутренняя политика управления изменениями они полезны.

\paragraph{\textbf{Oracle}} ~\\

 Oracle поддерживает DDL-триггеры с 8 версии (Oracle8i) под названием \textit{system triggers} или \textit{database event triggers}. Триггеры можно создавать как на уровне \texttt{SCHEMA} (схемы пользователя), так и на уровне \texttt{DATABASE} (всей базы данных) \autocite{oracledbdoc7}. 
 
 В синтаксисе \texttt{CREATE TRIGGER} вместо таблицы указывается, например, \texttt{ON SCHEMA} или \texttt{ON DATABASE}. Далее через \texttt{AFTER} или \texttt{BEFORE} указываются события DDL, на которые триггер реагирует. Oracle позволяет перечислить через \texttt{OR} множество событий, либо использовать обобщения (\texttt{AFTER DDL ON DATABASE} означает <<после любого DDL на уровне базы>>). Примеры событий: \texttt{CREATE}, \texttt{ALTER}, \texttt{DROP} на различные объекты, \texttt{LOGON}/\texttt{LOGOFF} (вход/выход пользователя), \texttt{STARTUP}/\texttt{SHUTDOWN} базы данных и др. Ниже пример аудита создания объектов (триггер срабатывает после создания любого объекта в схеме и записывает это в журнал):
 \begin{lstlisting}[language=SQL]
    CREATE OR REPLACE TRIGGER audit_schema_objects
    AFTER CREATE ON SCHEMA
    BEGIN
        INSERT INTO schema_audit(user, event, object, timestamp)
        VALUES(USER, 'CREATE',
            ora_dict_obj_type || ':' || ora_dict_obj_name,
            SYSDATE);
    END;
 \end{lstlisting}

Здесь использованы специальные функции \texttt{ora\_dict\_obj\_type} и \texttt{ora\_dict\_obj\_name}, предоставляемые Oracle внутри DDL-триггеров, которые возвращают тип и имя созданного объекта соответственно. Таким образом, при каждом \texttt{CREATE} объекте в этой схеме в таблицу \texttt{schema\_audit} будет добавляться запись с именем пользователя, событием, названием объекта и временем. Oracle также позволяет триггерам вызывать хранимые процедуры, как и в случае DML (вместо секции \texttt{BEGIN \ldots END} можно написать \texttt{CALL procedure(\ldots)} \autocite{oracledbdoc7}).

DDL-триггеры Oracle могут быть очень полезны для аудита и модификации поведения БД. К примеру, можно создать триггер, который при попытке создания таблицы с определённым шаблоном имени автоматически добавляет на неё политики безопасности или индекс. Или, как часто демонстрируется, можно с помощью \texttt{BEFORE DROP ON SCHEMA} запретить удаление важных таблиц, если не установлена какая-нибудь специальная контекстная переменная (имитируя <<безопасный режим>>).

Ограничения в Oracle схожи с ранее рассмотренными: DDL-триггеры всегда выполняются \texttt{AFTER} соответствующего события (нет \texttt{INSTEAD OF} или \texttt{BEFORE} на DDL) – хотя \texttt{BEFORE} DDL можно смыслить как <<перед выполнением команды>>, Oracle вместо этого предлагает использовать \texttt{AFTER} и откатывать внутри, если нужно отменить действие. Число триггеров на одно событие не ограничено, но без \texttt{FOLLOWS}/\texttt{PRECEDES} порядок их выполнения неопределён. Глубина вложенности также максимум 32, как упоминалось ранее \autocite{oracledbdoc8}. 

В остальном Oracle предоставляет очень гибкие средства в \texttt{DBMS\_STANDARD} и системных функциях для получения подробной информации о событии (типа \texttt{ora\_srv\_error\_msg} – текст ошибки, если триггер на событие ошибок и т.п.), что выходит за рамки нашего обзора.

\subsubsection{INSTEAD OF триггеры}

Особый вид триггеров – \texttt{INSTEAD OF} (дословно <<вместо>>) – предназначен для переопределения поведения по умолчанию некоторой операции. Чаще всего они используются на представлениях: позволяют сделать непрямо обновляемое представление обновляемым, явно описав, что делать при вставке/обновлении/удалении на это представление. \texttt{INSTEAD OF}-триггер, как следует из названия, срабатывает \textbf{вместо} выполнения указанного действия.
Например, \texttt{INSTEAD OF INSERT} на представлении перехватывает вставку и вместо неё выполняет заданное пользователем действие (например, вставляет данные в одну или несколько базовых таблиц).

\paragraph{\textbf{PostgreSQL}} ~\\

 В PostgreSQL триггеры с опцией \texttt{INSTEAD OF} могут создаваться \textbf{только на представлениях} и только построчные (\texttt{FOR EACH ROW}) \autocite{PostgreSQLdocc37}. Это в целом логично, так как основное предназначение – обеспечить вставку/обновление/удаление строк в сложные представления, которые сами по себе не хранят данных. Когда срабатывает \texttt{INSTEAD OF}-триггер на представлении, его функция должна сама выполнить необходимые изменения базовых таблиц и (для \texttt{INSERT}/\texttt{UPDATE}) вернуть ту версию данных, которая ожидается увидеть через представление \autocite{PostgreSQLdocc37}. Если \texttt{INSTEAD OF}-триггер не создан, PostgreSQL просто попытается либо переписать операцию на представление в операцию над базовой таблицей (если представление простое и обновляемое автоматически), либо вернёт ошибку для сложных случаев. 
 
 По сути \texttt{INSTEAD OF}-триггеры дают полную свободу разработчику в том, как обрабатывать изменения представлений. Начиная с PostgreSQL 10, помимо построчных \texttt{INSTEAD OF}-триггеров, разрешено объявлять на представлениях и обычные \texttt{BEFORE/AFTER}-триггеры уровня оператора – однако они срабатывают только в сочетании с \texttt{INSTEAD OF} (то есть, если определён \texttt{INSTEAD OF}, то можно ещё в начале или конце операции выполнить что-то на уровне представления) \autocite{PostgreSQLdocc37}. Без \texttt{INSTEAD OF} такой \texttt{BEFORE/AFTER} триггер на представлении не имел бы смысла, ведь операция перенаправляется на таблицу.

 Пример: предположим, есть представление, объединяющее сотрудников и отделы, и мы хотим разрешить вставку новых <<сотрудников с указанием отдела>> прямо в представление. Мы можем создать \texttt{INSTEAD OF INSERT} триггер на представлении, который при вставке строки разберёт данные: сначала вставит отдел в таблицу отделов (или найдёт существующий), затем вставит сотрудника в таблицу сотрудников, ссылаясь на созданный отдел. В результате внешнему пользователю можно делать \texttt{INSERT} в представление, а триггер <<под капотом>> разложит это на две реальные операции.

\paragraph{\textbf{MySQL}} ~\\

 MySQL \textbf{не поддерживает} триггеры \texttt{INSTEAD OF}. Как упоминалось, триггеры можно создавать только на таблицах, и попытка создать на представлении приведёт к ошибке. В случае необходимости сделать представление обновляемым в MySQL, придётся обходиться либо простыми представлениями (которые MySQL может самостоятельно обновлять, если они однозначно ссылаются на одну таблицу), либо логикой в приложении. Другой альтернативой (не эквивалентной \texttt{INSTEAD OF}, но иногда применимой) являются \textit{хранимые функции} в MySQL или логика уровня приложения.

\paragraph{\textbf{SQL Server}} ~\\

 SQL Server позволяет создавать \texttt{INSTEAD OF}-триггеры как на представлениях, так и на реальных таблицах. На таблицах \texttt{INSTEAD OF} триггер фактически заменяет собой выполнение операции, что может использоваться для нестандартной обработки (например, игнорировать или преобразовывать определённые изменения). Однако основное применение – сложные представления. В \texttt{CREATE TRIGGER} синтаксисе просто указывается \texttt{INSTEAD OF INSERT/UPDATE/DELETE} вместо \texttt{AFTER}. Внутри такого триггера, как и в \texttt{AFTER}, доступны таблицы \texttt{inserted}/\texttt{deleted} с предполагаемыми изменениями. Обычно логика заключается в том, чтобы взять эти данные и выполнить нужные \texttt{INSERT}/\texttt{UPDATE}/\texttt{DELETE} на базовых таблицах. SQL Server не запрещает иметь одновременно \texttt{INSTEAD OF} и \texttt{AFTER} триггеры на одном объекте, но на одно конкретное событие у объекта может быть либо то, либо другое (например, нельзя для \texttt{INSERT} одновременнно и \texttt{INSTEAD OF}, и \texttt{AFTER} – будет использоваться только \texttt{INSTEAD OF} при вставке, а \texttt{AFTER} может стоять на обновление, например). Обычно для представления делают \texttt{INSTEAD OF} триггеры, а на таблицах оставляют \texttt{AFTER}.
 
 Пример для представления: предположим, есть представление \texttt{DeptEmpView}, соединяющее таблицы \texttt{Departments} и \texttt{Employees} (один-ко-многим). Мы хотим разрешить удаление отдела через представление, чтобы автоматически удалялись его сотрудники или перемещались в другой отдел. Создаём \texttt{INSTEAD OF DELETE ON DeptEmpView}: внутри него из таблицы \texttt{deleted} получим \texttt{dept\_id} удаляемого отдела, выполним логику (например, удалим сначала всех сотрудников этого отдела, потом отдел) – таким образом внешне для пользователя операция прошла на представлении, а фактически данные скорректированы в таблицах.

\paragraph{\textbf{Oracle}} ~\\

 Oracle поддерживает \texttt{INSTEAD OF}-триггеры начиная с версии 8i, но \textbf{только на представлениях} (как и PostgreSQL). Синтаксис: \texttt{CREATE TRIGGER \ldots INSTEAD OF INSERT OR UPDATE OR DELETE ON \emph{view\_name} FOR EACH ROW \ldots}. Внутри триггера используются \texttt{:NEW} и \texttt{:OLD} для доступа к значениям, которые пытаются вставить/изменить, или которые были в удаляемой строке представления. Триггер должен выполнить соответствующие действия над базовыми таблицами. Стоит отметить, что в Oracle представления бывают сложными (джойны, агрегаты), и далеко не все можно сделать обновляемыми даже через \texttt{INSTEAD OF} триггер (например, представление с агрегатами не имеет однозначной интерпретации для вставки), но многие полезные случаи (джойны нескольких таблиц) с помощью триггеров обрабатываются. \texttt{INSTEAD OF}-триггеры – единственный способ сделать \textit{необновляемое} представление \textit{обновляемым} \autocite{oracledbdoc8}.
 
 Пример: имеется представление \texttt{EmpProjView}, отображающее <<сотрудник - проекты>> (многие-ко-многим, ссылаясь на таблицу связей). Чтобы при вставке в это представление автоматически добавлять запись в таблицу связей, создаётся \texttt{INSTEAD OF INSERT} триггер, который возьмёт \texttt{:NEW.emp\_id} и \texttt{:NEW.proj\_id} и вставит в таблицу \texttt{EmployeeProject(emp\_id, proj\_id)}. Аналогично, \texttt{INSTEAD OF DELETE} мог бы удалять связь, а \texttt{INSTEAD OF UPDATE} — либо запрещается (если нет ясного смысла), либо реализует изменение связей.
 
 Oracle не разрешает \texttt{INSTEAD OF} триггеры на таблицах, поскольку на таблицах есть иные механизмы (\texttt{BEFORE}/\texttt{AFTER}). Но Oracle позволяет иметь на одном представлении \texttt{INSTEAD OF}-триггер для каждой из трёх операций (insert, update, delete) – то есть до триггеров на представления то же ограничение: один триггер на комбинацию событие+представление, поскольку обычно вся логика для insert пишется в одном триггере, для update – в другом и т.д.

 \subsubsection{Системные триггеры и специальные случаи}

 Под <<системными>> триггерами в контексте данного раздела подразумеваются триггеры, реагирующие на события, выходящие за рамки конкретной таблицы или даже конкретной базы. Сюда относятся уже упомянутые DDL-триггеры на уровне схемы/сервера, а также триггеры на вход в систему, на завершение сеанса, на старт/остановку сервера и другие подобные события.

\paragraph{\textbf{PostgreSQL}} ~\\

 Как отмечалось, PostgreSQL не имеет механизма, аналогичного триггерам на вход/выход пользователя. Триггеры в PostgreSQL действуют либо на изменение данных (DML-триггеры), либо на DDL (event triggers). Таким образом, системных триггеров, например, на логон пользователя, тут нет. Решение задач аудита входов/выходов пользователей в PostgreSQL обычно достигается другими методами (рассмотрение серверных логов, расширения). Однако PostgreSQL предоставляет богатый механизм подписки на уведомления (\texttt{LISTEN/NOTIFY}) и фреймворк расширений, через которые можно реализовать часть задач, недоступных стандартными триггерами.

\paragraph{\textbf{MySQL}} ~\\

 В MySQL также отсутствуют какие-либо \texttt{LOGON} триггеры или аналогичные. Все триггеры привязаны только к таблицам (DML). Для задач аудита активности пользователей в MySQL прибегают к средствам вроде general query log, triggers на системные таблицы аудита (когда это применимо), или внешним средствам.

\paragraph{\textbf{SQL Server}} ~\\ 

 В SQL Server особый вид DDL-триггеров – \textbf{логон-триггеры} – позволяют выполнять код при событии входа (логина) пользователя на сервер. Такие триггеры создаются с опцией \texttt{ON ALL SERVER FOR LOGON}. В теле триггера через функцию \texttt{EVENTDATA()} можно получить, например, имя логина. Используя логон-триггер, можно реализовать ограничения на вход (например, сразу делать \texttt{ROLLBACK} \texttt{CONNECT} для нежелательных пользователей или в неурочное время) или аудит (заносить информацию о каждом подключении в таблицу). 
 
 Пример:
 \begin{lstlisting}[language=SQL]
    CREATE TRIGGER trg_restrict_sa
    ON ALL SERVER
    FOR LOGON
    AS
    BEGIN
        IF ORIGINAL_LOGIN() = 'sa'
        AND (SELECT COUNT(*) 
                FROM sys.dm_exec_sessions
                WHERE is_user_process = 1
                    AND original_login_name = 'sa') > 1
        BEGIN
            ROLLBACK;
        END
    END;
\end{lstlisting}

 Этот логон-триггер не позволяет пользователю \texttt{sa} иметь более одного одновременного сеанса, сразу разрывая новое подключение, если уже существует активный сеанс \texttt{sa}. Логон-триггеры, конечно, сильный инструмент для повышения безопасности, но требуют осторожности, так как ошибка в логон-триггере (например, бесконечный цикл \texttt{ROLLBACK}) может блокировать входы всем пользователям, включая администраторов, до отключения триггера в безопасном режиме. 
 
 Кроме логон-триггеров, других <<системных>> триггеров в SQL Server нет (понятие системных DDL-триггеров мы уже раскрыли – это триггеры на события \texttt{CREATE LOGIN}, \texttt{ALTER DATABASE} и т.п., которые технически схожи с обычными DDL-триггерами).

\paragraph{\textbf{Oracle}} ~\\

 Oracle, пожалуй, наиболее богата на системные триггеры. Помимо DDL-триггеров, Oracle поддерживает триггеры на события входа пользователя (\texttt{AFTER LOGON}), выхода пользователя (\texttt{BEFORE LOGOFF}), старт базы данных (\texttt{AFTER STARTUP}) и её останов (\texttt{BEFORE SHUTDOWN}), а также на события серверных ошибки (\texttt{AFTER SERVERERROR}) и даже на коммиты транзакций (\texttt{AFTER TRANSACTION}). Эти триггеры могут быть определены либо в масштабе всей базы данных, либо в масштабе определённой схемы пользователя. 
 Примеры использования:
 \begin{itemize}
    \item \textit{Аудит входов/выходов}. Создавая \texttt{AFTER LOGON ON DATABASE} триггер, можно фиксировать каждый факт подключения любого пользователя к базе, записывая \texttt{USER}, \texttt{USERHOST} и время в таблицу аудита. Аналогично \texttt{BEFORE LOGOFF} может фиксировать отключения или длительность сессии. В примере из документации Oracle показано создание триггеров \texttt{hr\_logon\_trigger} и \texttt{hr\_logoff\_trigger}, которые при входе/выходе пользователя \texttt{HR} вставляют запись в таблицу \texttt{hr\_users\_log} \autocite{oracledbdoc8}.
    \item \textit{Ограничения подключения}. Например, \texttt{AFTER LOGON ON DATABASE} триггер может проверять, не подключается ли пользователь с определённого IP-адреса или в нерабочее время, и выполнять \texttt{RAISE\_APPLICATION\_ERROR} для прерывания подключения с сообщением (фактически, отменяя вход для данного пользователя). Можно реализовать <<чёрный список>> клиентов или ограничение количества одновременных сессий более гибко, чем в варианте SQL Server.
    \item \textit{Логирование ошибок}. \texttt{AFTER SERVERERROR ON DATABASE} триггер может отлавливать определённые критические ошибки (например, падение серверного процесса, ORA-00600, или ошибки пространственного ограничения) и, к примеру, посылать уведомление администратору или записывать расширенную информацию в служебную таблицу.
    \item \textit{Какие-то действия при старте/остановке базы}. \texttt{AFTER STARTUP ON DATABASE} можно использовать, чтобы при запуске instance выполнять какие-то инициализационные процедуры (например, прогрев кэша, установка определённых параметров окружения).
    \item \texttt{BEFORE SHUTDOWN ON DATABASE} – для отсылки уведомлений или очистки временных данных и др.
 \end{itemize}

 Oracle предоставляет внутри системных триггеров специальные контекстные функции. Например, \texttt{USER} даёт имя пользователя, \texttt{DATABASE\_NAME} – имя базы, \texttt{SYS\_CONTEXT('USERENV','IP\_ADDRESS')} – IP клиента, \texttt{ora\_syserror} – код ошибки для \texttt{SERVERERROR} триггера и т.д. Это позволяет в коде триггера реагировать очень избирательно на ситуацию. 
 Конечно, все эти возможности требуют осторожности: например, логон-триггер, как и в SQL Server, может случайно закрыть доступ ко всем, если содержит баг. Поэтому обычно в коде таких триггеров стараются минимизировать действия (например, в логон-триггере не выполнять долгих запросов). Также в Oracle можно временно отключать триггеры (\texttt{ALTER TRIGGER DISABLE}) на время администрирования.

\subsubsection{Особенности и сравнение реализации триггеров}

Подведём итог по поддержке триггеров в различных СУБД. В таблице ниже приведено сравнение ключевых характеристик триггеров в PostgreSQL, MySQL, SQL Server и Oracle:

\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.2} 
    \begin{tabular}{|>{\raggedright\arraybackslash}p{3.5cm} | p{3.2cm} | p{3cm} | p{3cm} | p{3cm}|}
        \hline
        \textbf{Характеристика} & \textbf{PostgreSQL} & \textbf{MySQL} & \textbf{SQL Server} & \textbf{Oracle} \\
        \hline
        \textbf{DML-триггеры (таблицы)} & Да (до/после; \textit{statement} и \textit{row}) & Да (до/после; \textit{statement}) & Да (до/после) & Да (до/после; \textit{statement} и \textit{row}) \\
        \hline
        \textbf{Только row-триггеры} & Нет & Да (только row) & Нет & Нет \\
        \hline
        \textbf{DML-триггеры (представления)} & Да (\texttt{INSTEAD OF}) & Нет & Да (\texttt{INSTEAD OF}) & Да (\texttt{INSTEAD OF}) \\
        \hline
        \textbf{DDL-триггеры} & Да (event triggers с 9.3) & Нет & Да (на уровне сервера и БД) & Да (на уровне схемы или БД) \\
        \hline
        \textbf{События-сессии (логон и пр.)} & Нет & Нет & Частично (триггер на логон и др.) & Да (логон, start/stop, error и др.) \\
        \hline
        \textbf{Доступ к старым/новым значениям} & \texttt{OLD}, \texttt{NEW} (внутри тела триггера) & \texttt{OLD}, \texttt{NEW} & \texttt{inserted}, \texttt{deleted} (таблицы-сводки) & \texttt{:OLD}, \texttt{:NEW} (PL/SQL) \\
        \hline
        \textbf{Несколько триггеров на событие} & Да (по алфавиту имени) \autocite{Postgresqlcom} & Да (порядок не определён) \autocite{Mysqldoc5} & Да (порядок настраивается) \autocite{MicrosoftLearnDDLTrig} & Да (с 11g через \texttt{FOLLOWS}) \autocite{oracledbdoc8} \\
        \hline
        \textbf{Макс. вложенность (каскаду)} & Не ограничена (зависит от ресурсов) \autocite{Postgresqltrig} & Нет прямой рекурсии (запрещена) & 32 уровня (по умолчанию) \autocite{MicrosoftLearnNestTrig} & 32 уровня (по умолчанию) \\
        \hline
    \end{tabular}
    \caption{Поддержка триггеров в различных СУБД}
    \label{tab:trig-comp}
\end{table}


\vspace{0.5em}

\noindent\textbf{Ограничения и примечания:}

\begin{itemize}
    \item PostgreSQL: требуется функция; поддержка \texttt{WHEN} условия; нет триггеров на \texttt{TRUNCATE}.
    \item MySQL: нельзя модифицировать таблицу в триггере; нет поддержки \texttt{BEFORE} на представления; нет \texttt{TRANSACTION} в теле триггера.
    \item SQL Server: нет \texttt{BEFORE}, \texttt{INSTEAD OF} только для таблиц/представлений; гибкие события (логон и пр.); ограничение \textit{mutating table}.
    \item Oracle: до 11g один триггер на событие; далее \texttt{FOLLOWS} даёт явное управление порядком; ограничение \textit{mutating table}.
\end{itemize}

\vspace{0.5em}

Из таблицы видно, что PostgreSQL и Oracle обеспечивают наибольшую гибкость по видам триггеров, тогда как MySQL поддерживает лишь базовые DML-триггеры. SQL Server почти все виды поддерживает, за исключением \texttt{BEFORE}-триггеров.

Каждый подход диктует свой стиль использования. Например, в PostgreSQL часто логика триггера выносится в функцию, что упрощает отладку и повторное использование кода одним и тем же триггером на разных таблицах \autocite{Postgresqltrig}. 

В SQL Server же триггер – это по сути и есть тело процедуры, поэтому логика пишется прямо в нём, а повторное использование возможно через вызов обычных хранимых процедур из триггера. 

В Oracle можно выбирать между написанием логики непосредственно в \texttt{CREATE TRIGGER} (блок \texttt{BEGIN \ldots END}) или выносом в хранимую процедуру (\texttt{CALL proc(\ldots)}) \autocite{oracledbdoc7} – оба способа эквивалентны по возможностям.

Что касается производительности, триггеры добавляют оверхед к операциям: каждая модификация данных может приводить к дополнительным действиям. Поэтому использовать триггеры нужно обдуманно. В учебных примерах (как в этом пособии) они отлично подходят для иллюстрации сложных правил поддержания данных. Но в промышленном коде избыточное использование триггеров может затруднить сопровождение и отладку, поскольку логика <<разбрасывается>> по базе данных и срабатывает неявно. Как отмечают \autocite{Silberschatz} и другие, триггеры могут приводить к непреднамеренным последствиям, если разработчики не знают о них или не ожидают побочных изменений данных. Поэтому рекомендуется документировать наличие важных триггеров и тщательно тестировать их на отсутствие логических циклов и взаимных влияний.

В заключение, триггеры – механизм расширения функциональности СУБД, позволяющий реагировать на изменения данных автоматически. Они эффективны для задач, где нужно гарантированно применять бизнес-правило независимо от того, из какого приложения или под чьим запросом изменяются данные. Мы рассмотрели DML-триггеры, обеспечивающие целостность данных в таблицах (например, каскадное обновление связанных записей или аудит изменений), DDL-триггеры, помогающие контролировать изменения схемы и действия администраторов, \texttt{INSTEAD OF}-триггеры для пользовательских представлений, а также специальные системные триггеры для событий уровня базы данных. 

\subsection{Журналирование и резервное копирование} 

 Надёжная работа современных СУБД невозможна без механизмов журналирования транзакций и резервного копирования данных. Эти механизмы обеспечивают восстановление базы данных после сбоев и защиту от потери данных, гарантируя тем самым свойства атомарности и долговечности ACID \autocite{Silberschatz}. Ниже рассматриваются основы журналирования изменений и методов резервного копирования, а также их реализация в рассматриваемых нами СУБД: PostgreSQL, MySQL, Microsoft SQL Server и Oracle. 
 
\subsubsection{Логирование изменений} 

 Каждая СУБД ведёт специальный журнал транзакций, в который последовательно записываются все выполненные операции изменения данных \autocite{MicrosoftLearnSQLserverTransLog}. Журнал хранится на надёжном диске отдельно от основных данных и является ключевым компонентом системы: при сбое системы именно он позволяет привести базу данных к согласованному состоянию без потери подтверждённых транзакций \autocite{MicrosoftLearnSQLserverTransLog}. Запись действий в журнал происходит \textit{до} применения соответствующих изменений к самой базе данных. Такой подход называется журналом предзаписи (англ. \textit{Write-Ahead Logging}, WAL) и признан стандартным методом обеспечения целостности и устойчивости данных \autocite{PostgreSQLdocc28}. Основная идея WAL состоит в том, что перед тем как изменить страницу с данными на диске, СУБД сначала фиксирует информацию об этом изменении в журнале и сохраняет журнал на постоянном хранилище \autocite{PostgreSQLdocc28}. Только после успешной записи соответствующей журнальной записи операция считается надёжно зафиксированной, и изменения могут быть сброшены в основные файлы базы. Если придерживаться этого правила, отпадает необходимость немедленно записывать на диск каждую изменённую страницу данных при подтверждении транзакции, так как в случае сбоя система сможет восстановить недостающие изменения из журнала (так называемое восстановление с проигрыванием журнала, или операция \textit{REDO}) \autocite{PostgreSQLdocc28}. То есть протокол WAL позволяет достичь сразу двух целей: повысить надёжность транзакционной системы (за счёт сохранения всех действий на долговечном носителе) и увеличить производительность за счёт отложенной записи изменённых данных. Дисковые операции записи сводятся в основном к последовательной записи журнала, а сами страницы данных могут записываться реже (например, при фоновой синхронизации или контрольных точках). Практически одна операция синхронизации файла журнала (\texttt{fsync}) может подтвердить сразу множество небольших транзакций. Это существенно снижает количество случайных дисковых операций по сравнению с записью каждой страницы отдельно \autocite{PostgreSQLdocc28}. 
 
 Журналирование изменений открывает несколько возможностей:
 \begin{itemize}
    \item Во-первых, оно позволяет откатывать транзакции (отмена незавершённых операций) и восстанавливать БД после сбоев без потери данных – эти процедуры рассмотрены далее. 
    \item Во-вторых, журнал служит основой для резервного копирования с возможностью точечного восстановления: сохраняя копию базы и архивируя журнальные файлы, можно впоследствии восстановить состояние базы на любой момент времени, проиграв (прокрутив вперёд) журнальные записи изменений вплоть до нужной отметки \autocite{PostgreSQLdocc28}. 
    \item В-третьих, механизм журналов используется для репликации и повышения отказоустойчивости: изменения, зафиксированные в журнале, могут передаваться на запасные серверы и применяться там, поддерживая актуальную копию базы данных \autocite{Mysqldoc7}. 
 \end{itemize}
 Следует также отметить, что файлы журнала чрезвычайно важны для системы. Их удаление или повреждение без надлежащих процедур чревато потерей данных и невозможностью корректного восстановления \autocite{MicrosoftLearnSQLserverTransLog}. Поэтому СУБД обычно не только сама управляет сохранением и очищением (транкацией) журнала, но и предоставляет средства резервирования журналов (например, архивирования) для целей восстановления.

\subsubsection{Журналирование операций в различных СУБД} 

 Концепция транзакционного журнала реализована во всех промышленных СУБД, хоть названия и различаются. Рассмотрим, как организовано журналирование в PostgreSQL, MySQL, SQL Server и Oracle. 

 \paragraph{WAL в PostgreSQL} ~\\

 PostgreSQL использует протокол предзаписи WAL на уровне всего сервера. Все изменения базы записываются в журнальные файлы фиксированного размера (\textit{WAL segment}) в каталоге \texttt{pg\_wal/} (ранее \texttt{pg\_xlog/}). Запись в WAL происходит при каждом подтверждении транзакции: процесс-\texttt{logger} (\texttt{WAL Writer}) сбрасывает на диск буфер журнала, после чего транзакция считается зафиксированной. Благодаря этому при сбоях PostgreSQL может автоматически восстановить базу, проиграв журнальные записи всех транзакций, которые подтвердились, но чьи изменения не успели попасть в основное хранилище \autocite{PostgreSQLdocc28}. 
 
 WAL в PostgreSQL содержит \textit{физические} описания изменений на уровне страниц/байтов базы данных. Например, если транзакция добавила строку в таблицу, в WAL записывается информация о внесении определённых байтов на определённую страницу таблицы. При рестарте после сбоя сервер читает журнал и применяет все такие изменения ко всем страницам, доводя базу до актуального состояния (это операция \textit{REDO}). Кроме того, в WAL пишутся специальные записи для обозначения начала и конца транзакций, что позволяет при необходимости отменить (откатить) незавершённые транзакции. 
 
 PostgreSQL поддерживает механизмы архивирования WAL: администратор может включить режим архивации (\texttt{archive\_mode=on}) и задать команду архивирования (\texttt{archive\_command}), по которой сервер будет копировать каждый заполненный WAL-файл в стороннее хранилище (например, на другой диск или в облако). Архивирование WAL, в сочетании с регулярным резервным копированием, позволяет реализовать восстановление базы данных на любой момент времени (PITR): достаточно взять базовую резервную копию данных и прокрутить вперёд накопленные WAL-журналы до требуемого времени \autocite{PostgreSQLdocc28}. 
 
 Например, утилита \texttt{pg\_basebackup} позволяет создать <<снимок>> базы, не останавливая сервер; а для восстановления достаточно поместить архивные WAL-файлы в каталог \texttt{pg\_wal} и указать в конфигурации точку во времени для отката (\texttt{recovery\_target\_time}). PostgreSQL применит журнальные записи и восстановит состояние базы на указанный момент. 
 
 Механизм WAL также применяется для репликации: в режиме потоковой репликации (\textit{streaming replication}) основной сервер (\textit{primary}) транслирует свой WAL в реальном времени на один или несколько резервных узлов (\textit{standby}), которые постоянно повторяют полученные изменения у себя. Таким образом достигается почти синхронное дублирование данных на случай сбоя основного сервера.

 \paragraph{Бинарный лог в MySQL} ~\\
 
 В MySQL журнальный механизм представлен \textit{бинарным журналом} (binary log, \textbf{binlog}). Бинарный журнал содержит последовательность \textit{событий}, описывающих изменения в базе данных. В него записываются все SQL-команды, приводящие к модификации данных (например \texttt{CREATE TABLE}, \texttt{INSERT}, \texttt{UPDATE} и т.д.), а также информация о времени выполнения этих команд \autocite{Mysqldoc7}. Команды, не изменяющие данные (например, \texttt{SELECT}), в бинарный лог не попадают.
 
 MySQL поддерживает два основных формата ведения binlog: \textit{пооператорный} (statement-based, когда логируются сами SQL-выражения) и \textit{построчный} (row-based, когда в журнал записываются непосредственно изменённые строки). Независимо от формата, бинарный лог выполняет две функции. \textbf{Первая функция} — это репликация: binlog на основном сервере (\textit{master}) служит источником данных для реплик. Специальный поток (\textit{replication thread}) читает журнал и отправляет записанные в нём события на серверы-реплики, которые применяют эти события и тем самым воспроизводят все транзакции, произошедшие на основном сервере \autocite{Mysqldoc7}. \textbf{Вторая функция} — это восстановление данных после сбоев и ошибок пользователя. Если у администратора имеется резервная копия базы данных (например, дамп или образ файлов), то с помощью бинарного журнала можно <<доиграть>> изменения, произошедшие после снятия копии, и восстановить состояние базы на нужный момент \autocite{Mysqldoc7}. Подобная техника реализует точечное восстановление (PITR) аналогично описанному для PostgreSQL: сначала из бэкапа восстанавливаются данные, затем прикладываются операции из binlog. Для этого используется утилита \texttt{mysqlbinlog}, которая позволяет фильтровать события журнала по времени или позициям и применить их к серверу. 
 
 К примеру, если известно, что ошибочное удаление данных произошло примерно в 09:02, можно выполнить восстановление до 09:00 следующим образом:

 \begin{lstlisting}[language=bash]
    mysqlbinlog --start-datetime="2025-06-10 08:00:00" \
                --stop-datetime="2025-06-10 09:00:00" \
    /var/lib/mysql/binlog.000001 | mysql -u root -p
 \end{lstlisting}
 
 В приведённом примере утилита извлекает из файлов бинарного лога все транзакции с 8:00 до 9:00 и передаёт их серверу MySQL для выполнения – в результате база данных будет приведена в состояние на 9:00, т.е. непосредственно перед нежелательной операцией. Бинарный лог в MySQL включается опцией \texttt{--log-bin} (в современных версиях он часто включён по умолчанию). Следует отметить, что помимо binlog механизма MySQL (точнее, механизм хранения InnoDB) имеет и свой внутренний \textit{redo-лог} для целей crash-восстановления. Внутренний redo-лог используется при перезапуске сервера после сбоя, чтобы закончить незавершённые транзакции и откатить прерванные изменения – аналогично тому, как это делают другие СУБД. Однако этот внутренний лог недоступен для пользователя и не предназначен для архивации. Напротив, бинарный журнал MySQL предназначен именно для внешнего использования - с его помощью реализуются репликация и восстановление после аварий, и администратор может управлять сохранением binlog (например, настроить его периодическую очистку, сколько дней хранить журналы, или копировать их для архива). Включение binlog добавляет небольшие накладные расходы, несколько замедляя работу сервера, но это обычно оправдано с точки зрения возможности репликации и восстановления \autocite{Mysqldoc7}. 
 
 Важно понимать, что binlog не защищает от всех видов сбоев. Например, если с диском произошла авария, из одного только журнала нельзя восстановить базу без резервной копии данных; а при логических ошибках (например, случайное \texttt{DROP TABLE}) журнал зафиксирует эту операцию и реплики её повторят. Поэтому binlog обычно используется в сочетании с регулярными резервными копиями и для репликации в режиме High Availability.

 \paragraph{Транзакционный лог в SQL Server} ~\\

 В Microsoft SQL Server для каждой базы данных определяется свой \textit{транзакционный журнал} (transaction log). Физически он хранится в отдельных файлах с расширением \texttt{.ldf}. В этот журнал последовательно записываются все изменения, происходящие в базе, включая операции вставки, обновления, удаления данных, а также изменения структуры (DDL) \autocite{MicrosoftLearnSQLserverTransLog}. Логические операции (например, выполнение SELECT) не журналируются, но любые изменения состояния базы (в том числе системных каталгов) фиксируются. 
 
 Транзакционный лог SQL Server, как и WAL, обеспечивает надёжность: если сервер аварийно завершится, при следующем запуске он автоматически выполнит \textit{recovery} каждой базы данных, используя её журнал \autocite{MicrosoftLearnSQLserverTransLog}. В процессе автоматического восстановления SQL Server <<прокручивает вперёд>> (\textit{roll forward}) все изменения из лога, которые могли не сохраниться на диск к моменту сбоя, а также <<откатывает>> (\textit{roll back}) эффекты всех транзакций, которые не успели завершиться до сбоя \autocite{MicrosoftLearnSQLserverTransLog}. Благодаря этому достигается тот же эффект, как если бы незавершённые транзакции не выполнялись вовсе, а все подтверждённые – полностью сохранились. Кроме того, транзакционный лог позволяет выполнять откат индивидуальных транзакций по запросу пользователя (команда \texttt{ROLLBACK}) – СУБД читает из журнала ранее сохранённые <<старые>> значения и обращает изменения транзакции в обратном порядке \autocite{MicrosoftLearnSQLserverTransLog}. 
 
 Также транзакционный лог в SQL Server используется как часть стратегии резервного копирования. Администратор может делать резервные копии самого журнала (\texttt{BACKUP LOG}) через определённые интервалы времени. Такие копии сохраняют все зафиксированные операции транзакций за период и позволяют при необходимости восстановить базу данных к произвольному моменту между полными резервными копиями. Например, после сбоя можно восстановить последовательно полный бэкап базы, дифференциальный бэкап (если использовался), а затем по порядку журнальные бэкапы – и тем самым <<докрутить>> базу до состояния непосредственно перед сбоем \autocite{MicrosoftLearnSQLserverTransLog}. SQL Server при применении каждого лога воспроизводит все записанные в нём изменения (REDO), а после применения последнего лога откатывает все незавершённые к тому моменту транзакции (UNDO), обеспечивая целостность \autocite{MicrosoftLearnSQLserverTransLog}. Таким образом реализуется точечное восстановление аналогично другим системам. 
 
 Хранение журнала в SQL Server управляется \textit{моделями восстановления}: в режиме \texttt{FULL} или \texttt{BULK\_LOGGED} журнал сохраняет всю историю операций и требует регулярного архивирования (бэкапа) журнала, после каждого из которых пространство журнала может быть очищено (т.е. старые записи могут быть усечены). В упрощённом режиме \texttt{SIMPLE} журнал автоматически усекается системой после каждой контрольной точки, не накапливая полную историю транзакций – однако в этом режиме невозможно точечное восстановление, только откат ко времени последнего полного бэкапа. Администратор может принудительно выполнять команду \texttt{CHECKPOINT} (например, перед выключением сервера), чтобы сбросить на диск все изменения и облегчить последующее восстановление. Журнал также лежит в основе механизмов репликации и высокой доступности в экосистеме SQL Server. Так, при \textit{transactional replication} специальный процесс (\textit{Log Reader Agent}) читает транзакционный лог и вытаскивает из него подтверждённые транзакции, помеченные для репликации, копируя их в распределительную базу для рассылки подписчикам \autocite{MicrosoftLearnSQLserverTransLog}. 
 
 Функции высокой готовности – такие как зеркалирование баз данных, \textit{AlwaysOn Availability Groups} и \textit{лог-шиппинг} – также полагаются на журнал: изменения из лога основного сервера отправляются на запасной сервер и там тоже записываются в журнал и применяются, что позволяет вторичной базе постоянно находиться на актуальном <<прокрученном вперёд>> состоянии \autocite{MicrosoftLearnSQLserverTransLog}.

 \paragraph{Redo-журнал в Oracle} ~\\
 
 В Oracle механизм журналирования реализован через \textit{redo log} – набор как минимум из двух redo-файлов, которые используются по круговой схеме. Каждый экземпляр Oracle Database имеет свой набор redo log-файлов; при группировке в кластер (Real Application Clusters, RAC) у каждого узла свой <<поток>> журнала, чтобы избежать конкуренции за один файл \autocite{OracleRedoLog}. В обычной (standalone) конфигурации обычно имеется две группы журналов, каждая минимум с одним файлом, и они по очереди активны: когда текущий файл заполняется, происходит переключение лога (log switch) – Oracle начинает писать в следующий файл, а предыдущий помечается как неактуальный. Redo log хранит \textit{записи повторного выполнения} (\textit{redo records}), содержащие так называемые векторы изменений (change vectors) для отдельных блоков данных \autocite{OracleRedoLog}. Иначе говоря, каждая запись журнала Oracle описывает изменение, произошедшее с конкретным блоком базы данных. 
 
 Например, если транзакция изменяет значение некоторой строки, в redo-запись войдут фрагменты: изменение в блоке данных таблицы, соответствующее изменение в блоке сегмента отката (undo) и обновление в блоке транзакционной таблицы (списка активных транзакций) \autocite{OracleRedoLog}. То есть журнал Oracle фиксирует все изменения, включая изменения в сегментах отката, и тем самым защищает также данные для отката транзакций.
 
 Процесс записи журнала (\textit{Log Writer}, LGWR) работает подобно другим СУБД: при подтверждении транзакции LGWR сбрасывает из буфера SGA на диск все связанные с ней записи redo log и присваивает им \textit{SCN} (System Change Number – глобальный порядковый номер изменений) \autocite{OracleRedoLog}. Только после того, как все соответствующие журнальные записи надежно записаны на диск, транзакция считается зафиксированной. Если журнал заполняется до завершения транзакции (или другой транзакции), LGWR может сбросить и незавершённые на данный момент записи – это не проблема, поскольку при откате транзакции изменения, которые были записаны в журнал авансом, просто не будут применены либо будут компенсированы отдельными записями отката. При рестарте после сбоя Oracle выполняет \textit{автовосстановление экземпляра} (instance recovery): процесс \textit{SMON} читает текущий активный журнал и при необходимости архивированные журналы, чтобы повторно применить все изменения из redo log (ROLL FORWARD), завершив тем самым все транзакции, чьи коммиты подтверждены в журнале, и затем отменить (ROLL BACK) все транзакции, которые на момент сбоя не имели отметки о коммите \autocite{OracleRedoLog}. Эта процедура происходит автоматически при старте, позволяет базе данных восстановиться до консистентного состояния без вмешательства администратора.

 Особенностью Oracle является механизм архивирования журналов. По умолчанию база работает в режиме \texttt{NOARCHIVELOG} - при заполнении redo-файлы переиспользуются (перезаписываются) по кругу. Для возможности восстановления после более серьёзных сбоев (например, отказ диска) обычно включается режим \texttt{ARCHIVELOG} - тогда после каждого переключения журнала система фоновым процессом \textit{ARCH} сохраняет копию заполненного redo-файла в указанное хранилище (архивные логи). Накопленные архивные журналы вместе с резервной копией базы позволяют восстановить данные при повреждении диска: достаточно восстановить файлы данных из бэкапа и затем применить последовательно все архивные redo-логи, докручивая базу до актуального состояния или до требуемого пункта во времени. В Oracle для этого чаще всего используется утилита RMAN (Recovery Manager), либо команды SQL*Plus: \texttt{RECOVER DATABASE UNTIL TIME \ldots} и т.п. Redo-журналы также используются для организации репликации. 
 
 Продукт Oracle Data Guard позволяет поддерживать синхронную или асинхронную реплику базы данных. Основной экземпляр в режиме реального времени отправляет свои redo-записи на удалённый резервный сервер, где эти изменения непрерывно применяются. При отказе основного узла резервный может мгновенно принять на себя работу с минимальной потерей данных (в случае синхронной репликации – с нулевой потерей). Аналогичные возможности, кстати, существуют и в других СУБД (например, синхронные реплики в SQL Server, режим \texttt{synchronous\_commit} в PostgreSQL и т.д.).
 
 \begin{table}[H]
    \centering
    \begin{tabular}{|c|p{4.25cm}|p{7.75cm}|}
        \hline
        \textbf{СУБД} & \textbf{Механизм журнала} & \textbf{Назначение и применение} \\
        \hline
        PostgreSQL & Write-Ahead Log (WAL), <<журнал предзаписи>> & Запись физических изменений страниц базы перед фиксацией транзакции. Обеспечивает аварийное восстановление (REDO/UNDO при перезапуске), используется для онлайн-бэкапов и PITR (архивирование WAL) и для потоковой репликации на резервные узлы. \autocite{PostgreSQLdocc28} \\
        \hline
        MySQL & Binary Log (binlog), <<бинарный журнал>> & Запись логических событий изменений (SQL-команд или строковых изменений). Обеспечивает репликацию на уровне SQL/строк (передача событий репликам) и точечное восстановление после аварий (применение binlog к резервной копии). Не используется для автоматического crash-восстановления (эту функцию выполняет внутренний InnoDB redo log). \autocite{Mysqldoc7} \\
        \hline
        SQL Server & Transaction Log, <<транзакционный журнал>> & Запись всех операций изменения данных и схемы. Обеспечивает полноту ACID: при сбоях СУБД автоматически откатывает незавершённые транзакции и доделывает записанные. Поддерживает резервное копирование журнала и восстановление на время (RESTORE LOG ... STOPAT). Используется для механизмов высокой доступности (AlwaysOn, зеркалирование, лог-шиппинг) и транзакционной репликации. \autocite{MicrosoftLearnSQLserverTransLog} \\
        \hline
        Oracle & Redo Log, <<журнал повторных изменений>> & Запись низкоуровневых изменений во всех блоках данных базы. Обеспечивает надёжность транзакций; при сбоях Oracle выполняет автоматический \textit{roll-forward} всех изменений из журнала и откат незавершённых. Имеет несколько групп файлов в круговом использовании; в режиме ARCHIVELOG сохраняется для восстановления базы из бэкапов до любого времени. Используется для репликации Data Guard (передача redo на резервный standby). \autocite{OracleRedoLog} \\
        \hline
    \end{tabular}
    \caption{Механизмы транзакционного журналирования в разных СУБД}
    \label{tab:txn_logging_mechanisms}
\end{table}

\subsubsection{Операции восстановления: прокрутка вперёд и откат} 
 
 Механизм журналирования позволяет СУБД выполнять \textit{восстановление} базы данных после сбоев, выполняя две основные процедуры: \textit{повторение подтверждённых операций} и \textit{отмену незафиксированных изменений}. В теории восстановления эти две процедуры называются \textbf{REDO} (повторное применение или <<прокрутка вперёд>>) и \textbf{UNDO} (отмена или <<откат назад>>) \autocite{ElmasriNavathe}. При сбое системы (например, внезапном выключении питания) в журнале могут остаться записи операций, которые ещё не были применены к основным файлам базы, а также могут присутствовать незавершённые транзакции. При перезапуске СУБД просматривает журнал и выполняет восстановление в два этапа. Сначала производится REDO всех операций, которые были зафиксированы (commit) до момента сбоя, но чьи результаты не успели записаться в базу данных \autocite{ElmasriNavathe}. По журнальным записям система повторяет эти изменения, чтобы довести базу до состояния, в котором находятся все завершённые транзакции. После этого выполняется UNDO для всех транзакций, которые были активны на момент сбоя (т.е. не успели подтвердиться) \autocite{ElmasriNavathe}. Используя журнальные записи старых значений (так называемые \textit{undo-лог}), система отменяет все частичные эффекты этих прерванных транзакций, возвращая базу к консистентному состоянию, как если бы незавершённые транзакции не выполнялись вовсе. Такой алгоритм восстановления (REDO потом UNDO) реализован, например, в методике ARIES, используемой во многих СУБД \autocite{Silberschatz}. В некоторых реализациях порядок может быть обратным (сначала UNDO незавершённых, затем REDO завершённых), но конечный результат одинаков. 
 
 Рассмотрим простой пример для иллюстрации. Пусть транзакция переноса денег списывает \textdollar 100 со счёта A и зачисляет их на счёт B. Предположим, операция со счёта A прошла, а операция на счёт B ещё не записана, когда произошёл сбой. В журнале будет запись об успешном вычитании \textdollar 100 с A, но транзакция не зафиксирована. При восстановлении система обнаружит незавершённую транзакцию и выполнит откат: по undo-записи вернёт \textdollar 100 обратно на счёт A. Таким образом, частично выполненная транзакция не повлияет на состояние базы. Если же, наоборот, транзакция успела подтвердиться, но деньги на счёт B ещё не записались на диск, то при перезапуске механизм REDO найдёт в журнале запись о зачислении \textdollar 100 на B и повторит её, доведя операцию до завершения. В обоих случаях целостность данных будет сохранена благодаря журналу. 
 
 Важно отметить, что операции REDO и UNDO применяются не только при полном сбое системы, но и в других ситуациях. Например, если пользователь или приложение выполняет откат транзакции (\texttt{ROLLBACK}), СУБД читает журнал и делает UNDO для всех изменений данной транзакции, восстанавливая исходные значения тех данных, которые она изменила \autocite{MicrosoftLearnSQLserverTransLog}. Аналогично, при восстановлении базы из резервной копии на точный момент времени (PITR) применяется операция REDO для всех журналов от момента бэкапа до целевого времени, после чего могут быть отменены транзакции, выходящие за предел нужного момента.

\subsubsection{Контрольные точки} 

 При непрерывном журналировании объем журнала со временем растёт, а для восстановления теоретически понадобилось бы просканировать весь журнал с начала времён. Чтобы ограничить длину цепочки восстановления и избежать избыточного накопления журналов, СУБД используют механизм \textit{контрольных точек} (\textit{checkpoint}). 
 \begin{grayquote}
    \textbf{Контрольная точка} – это специальная точка во времени, когда система фиксирует, что база данных приведена в консистентное состояние на диске, согласованное с определённой pozицией журнала. 
 \end{grayquote}
 Иными словами, во время контрольной точки СУБД выполняет синхронизацию основных данных с журналом. 
 
 Создание контрольной точки обычно включает следующие шаги \autocite{ElmasriNavathe}: 
 \begin{enumerate}
    \item Приостановка поступления новых транзакций (очень кратко или логически, как в \textit{fuzzy checkpoint})
    \item Принудительная запись на диск всех изменённых буферов страниц (\textit{flush dirty pages}), чтобы все изменения, выполненные до этого момента, действительно оказались в файлах данных
    \item Запись специальной отметки – записи контрольной точки – в журнал транзакций и сброс этой записи на диск
 \end{enumerate}
 
 В журнале контрольная точка обычно содержит идентификатор текущей позиции (LSN, log sequence number) и список активных транзакций на данный момент. После этого выполнение транзакций возобновляется (если оно приостанавливалось). Контрольная точка устанавливает границу, до которой все предыдущие журнальные записи уже не нужны для восстановления полного состояния базы, так как все изменения до этой границы уже присутствуют в данных на диске \autocite{ElmasriNavathe}. 
 
 При аварийном восстановлении СУБД может начать процедуру REDO не с самого начала лога, а с последней контрольной точки. Например, Oracle и SQL Server при старте читают журнал от последней отметки \texttt{checkpoint} и восстанавливают изменения начиная с неё, что значительно ускоряет recovery. Журнальные записи, предшествующие самой последней контрольной точке, обычно не нужны для восстановления после сбоя и могут быть отброшены или архивированы. Более того, многие системы освобождают пространство журнала (транкуют лог) именно до последней контрольной точки, тем самым ограничивая рост файла журнала. 
 \begin{itemize}
    \item В PostgreSQL контрольная точка происходит автоматически по наступлении одного из условий: либо проходит определённый интервал времени (параметр \texttt{checkpoint\_timeout}, по умолчанию 5 минут), либо журнал WAL вырастает на заданный объем, либо по команде пользователя (\texttt{CHECKPOINT}). При контрольной точке PostgreSQL записывает в журнал специальную запись \texttt{CHECKPOINT} с номером последнего WAL-сегмента и обеспечивает сброс всех грязных страниц на диск. 
    \item В MySQL (InnoDB) контрольные точки выполняются непрерывно в фоновом режиме (так называемый \textit{fuzzy checkpoint}), записывая изменённые страницы, чтобы удерживать объем внутреннего буфера изменений. 
    \item SQL Server самостоятельно выполняет checkpoint примерно каждые несколько минут (в зависимости от нагрузки, параметра \texttt{recovery interval} или по явной команде), отмечая его в своём журнале. 
    \item Oracle осуществляет контрольную точку при каждом переключении redo log-файлов, а также периодически по таймеру; при этом процесс \textit{CKPT} обновляет заголовки файлов данных и контрольного файла, фиксируя, до какого SCN данные актуальны на диске. 
 \end{itemize}

 Контрольные точки позволяют существенно сократить время восстановления и объем обрабатываемых журнальных данных. Например, если база работала месяц без перерыва, но контрольные точки происходили каждые несколько минут, то в случае сбоя для восстановления понадобится применить лишь последние несколько минут журнала, а не весь месяц операций. Кроме того, контрольные точки косвенно ограничивают размер активного журнала: после успешного создания новой контрольной точки предыдущие журналы могут быть помечены как не нужные для аварийного восстановления. Однако следует учитывать, что во время контрольной точки система вынуждена интенсивно работать с диском (сбрасывать страницы), что может временно снизить производительность. Современные СУБД используют оптимизированные или <<размытые>> (\textit{fuzzy}) контрольные точки, при которых транзакции не блокируются на всё время записи на диск: запись контрольной точки в журнал делается сразу, после чего новые транзакции могут продолжаться, пока остальные страницы дописываются в фоновом режиме \autocite{ElmasriNavathe}. Таким образом достигается баланс между скоростью работы в обычном режиме и скоростью восстановления после сбоя.

\subsubsection{Резервное копирование и репликация} 

 Помимо журнала транзакций, важнейшим элементом системы защиты данных является регулярное резервное копирование базы данных. Резервные копии (\textit{backups}) позволяют восстановить базу в случае серьёзных сбоев, например отказа диска или удаления данных пользователем. Существует несколько типов резервного копирования: \textit{полное} (сохранение всей базы целиком), \textit{дифференциальное} (сохранение изменений с момента последнего полного бэкапа) и \textit{инкрементальное} (сохранение изменений с момента предыдущего бэкапа любого типа). Также различают \textit{физическое} копирование файлов базы данных и \textit{логическое} копирование (дамп структур и данных в виде SQL-скриптов, например через утилиту \texttt{mysqldump} или \texttt{pg\_dump}). Выбор стратегии зависит от требований к времени восстановления и доступных ресурсов хранилища. 
 
 Одной из продвинутых возможностей, поддерживаемых журналированием, является \textbf{точечное восстановление} (Point-in-Time Recovery, PITR) – восстановление базы данных на произвольный момент времени в прошлом. Как обсуждалось ранее, PITR достигается комбинированием резервной копии и журнала транзакций. Сначала производится восстановление базы из последнего имеющегося бэкапа (это откатывает состояние базы к тому моменту, когда делалась копия). Затем применяются журнальные записи (WAL, binlog, архивные redo и т.п.), чтобы <<докрутить>> базу до желаемого состояния. При этом можно остановить проигрывание журнала в нужной точке – например, непосредственно перед выполнением ошибочной операции. Благодаря PITR администратор может, к примеру, вернуть базу к состоянию на вчерашний вечер или на любое время до момента ухудшающих изменений. Все четыре рассматриваемые СУБД поддерживают механизмы PITR. В PostgreSQL для этого необходимо включенное WAL-архивирование: указав параметр \texttt{recovery\_target\_time} или \texttt{recovery\_target\_xid} и располагая непрерывной последовательностью WAL-файлов, можно откатить базу ко времени T. В MySQL точечное восстановление осуществляется применением бинарного лога, как показано выше (можно указать диапазон времени или конкретные позиции журнала для восстановления \autocite{Mysqldoc7}). В SQL Server PITR возможен при условии режима полного восстановления: при восстановлении базы командой \texttt{RESTORE DATABASE \ldots WITH NORECOVERY} затем выполняются \texttt{RESTORE LOG} для всех журнальных бэкапов по порядку, с опцией \texttt{STOPAT ='T'}, где \texttt{T} – требуемое время \autocite{MicrosoftLearnSQLserverTransLog}. После применения последнего лога выполняется \texttt{RESTORE \ldots WITH RECOVERY} для завершения процесса. В Oracle точечное восстановление обычно производится через RMAN, командой \texttt{RECOVER DATABASE UNTIL TIME 'T'} с указанием времени или SCN. Таким образом, наличие полных резервных копий и архивированных журналов транзакций даёт большую гибкость в откате базы данных к прошлому состоянию, что важно при логических ошибках (например, случайное удаление данных) или обнаружении коррупции данных. 
 
 Стоит отдельно обсудить роль репликации в обеспечении отказоустойчивости. 
 \begin{grayquote}
    \textbf{Репликация} – это поддержание актуальных копий базы данных на нескольких узлах (серверах). 
 \end{grayquote}
 
 Обычно репликация настраивается для повышения доступности. То есть если основной сервер выходит из строя, на его место быстро переключается один из реплика-серверов, обладающий почти идентичными данными. Репликация может быть \textit{синхронной} (когда транзакция считается завершённой только после применения на резервном узле, что минимизирует потерю данных при сбое, но замедляет работу) или \textit{асинхронной} (основной сервер не ждёт подтверждения от реплики, данные доходят с небольшой задержкой). Механизмы репликации тесно связаны с журналированием - как уже упоминалось, изменения чаще всего передаются на реплики именно через журнал транзакций. Например, MySQL отправляет события из бинарного лога на реплики, PostgreSQL передаёт свой WAL на standby-серверы, SQL Server в режимах высокой доступности пересылает записи своего лога на вторичные реплики, Oracle Data Guard передаёт redo-записи на standby-базу \autocites{Mysqldoc7}{MicrosoftLearnSQLserverTransLog}. То есть по сути, транзакционный журнал служит <<транспортом>> изменений для репликации. 
 
 Репликация существенно повышает отказоустойчивость системы. При выходе из строя одного узла клиенты могут переключиться на другой узел с актуальными данными, почти не прерывая работу приложения. Однако репликация \textit{не заменяет} собой резервное копирование. Если данные на основном сервере были повреждены или ошибочно изменены (например, выполнено ошибочное удаление таблицы), то эти изменения обычно мгновенно реплицируются на все узлы и резервные копии базы таким способом не сохраняются \autocite{mariaBackup}. Как отмечается в документации MariaDB, репликация сама по себе не обеспечивает защиту от логических ошибок или потери данных – она лишь защищает от отказа оборудования основного сервера, но не избавляет от необходимости иметь резервные копии \autocite{mariaBackup}. Поэтому на практике стратегия обеспечения надёжности включает обе технологии: и репликацию (для высокой доступности в режиме реального времени), и регулярное резервное копирование (для возможности восстановить данные при повреждениях или откатиться к прошлым версиям данных). Комбинация правильно настроенного журналирования, репликации и бэкапов позволяет достичь в целом и устойчивости к сбоям аппаратуры, и защиты от потери данных, обеспечивает целостность и непрерывность работы базы данных даже.